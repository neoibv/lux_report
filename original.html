<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì—‘ì…€ ë°ì´í„° ê¸°ë°˜ ë¬¸í•­ ë¶„ì„ê¸°</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/wordcloud2.js/1.1.1/wordcloud2.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    {/* ZIP ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¶”ê°€ */}
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        body { font-family: 'Inter', sans-serif; }
        /* Section Headers */
        .section-header {
            font-size: 1.5rem; font-weight: 600; margin-bottom: 1rem;
            color: #4A5568; padding-bottom: 0.5rem; border-bottom: 2px solid #E2E8F0;
        }
        .subsection-header {
            font-size: 1.25rem; font-weight: 600; color: #2d3748;
            margin-top: 1.5rem; margin-bottom: 1rem; padding-bottom: 0.5rem;
            border-bottom: 1px solid #cbd5e0;
        }
        /* Wrapper for charts and summaries */
        .viz-wrapper {
            background-color: #fff; padding: 1.5rem; border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
            width: 100%; margin-bottom: 1.5rem;
            display: flex; 
            flex-direction: column; 
        }
        /* Responsive layout for wrappers */
        @media (min-width: 768px) { /* md */
            .viz-wrapper { width: calc(50% - 0.75rem); } 
        }
        @media (min-width: 1024px) { /* lg */
            .viz-wrapper { width: calc(33.3333% - 1rem); } 
            .viz-wrapper.full-width-lg { width: calc(66.6666% - 1rem); } 
            .viz-wrapper.full-width-xl { width: 100%; } 
        }
        /* Chart canvas container */
        .chart-canvas-container { position: relative; height: 300px; width:100%; flex-grow: 1; margin-top: 0.5rem; /* ì ìˆ˜ í‘œì‹œ í›„ ì•½ê°„ì˜ ê°„ê²© */ }
        /* Subjective Response Container */
        .subjective-responses-container {
            height: 300px; /* Match chart height */
            overflow-y: auto;
            border: 1px solid #e2e8f0; /* border-slate-200 */
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.75rem; /* p-3 */
            background-color: #f8fafc; /* bg-slate-50 */
            font-size: 0.875rem; /* text-sm */
            color: #334155; /* text-slate-700 */
            line-height: 1.6; /* leading-relaxed */
            flex-grow: 1;
        }
        .subjective-responses-container p { margin-bottom: 0.5rem; }


        #chartsArea { display: flex; flex-wrap: wrap; gap: 1.5rem; }
        
        /* Average Score Display Styling */
        .average-score-display {
            margin-bottom: 0.25rem; /* ì´ ì‘ë‹µ ìˆ˜ì™€ì˜ ê°„ê²© */
        }
        .average-score-text {
            font-size: 0.95rem; /* ì•½ê°„ í¬ê²Œ */
            font-weight: 600; /* ë³¼ë“œ ì²˜ë¦¬ */
            color: #1e293b; /* Tailwind: text-slate-800, ë” ì§„í•œ ìƒ‰ */
            margin-bottom: 0.35rem; /* ë°”ì™€ì˜ ê°„ê²© */
        }
        .average-score-bar-container {
            width: 100%;
            height: 1.25rem; 
            background-color: #e5e7eb; 
            border-radius: 0.375rem; 
            overflow: hidden; 
        }
        .average-score-bar-fill {
            height: 100%;
            background-color: #3b82f6; 
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75rem; 
            font-weight: 500; 
            transition: width 0.5s ease-in-out;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.2);
        }
        .total-responses-text {
            font-size: 0.8rem;
            color: #64748b; /* slate-500 */
            margin-bottom: 0.75rem; /* ì°¨íŠ¸ì™€ì˜ ê°„ê²© */
            text-align: right;
        }

        .toggle-button {
            background-color: #eef2ff; color: #3730a3; padding: 0.5rem 1rem;
            border-radius: 0.375rem; font-weight: 500; transition: background-color 0.2s;
            display: flex; justify-content: space-between; align-items: center; width: 100%; text-align: left;
        }
        .toggle-button:hover { background-color: #e0e7ff; }
        .toggle-icon { display: inline-block; transform: rotate(0deg); transition: transform 0.2s; }
        .toggle-icon.open { transform: rotate(90deg); }
        .remove-button {
            background-color: #fee2e2; color: #991b1b; padding: 0.25rem 0.5rem;
            border-radius: 0.375rem; font-size: 0.75rem; font-weight: 500;
            margin-left: auto;
        }
        .remove-button:hover { background-color: #fecaca; }
        .radio-label { margin-left: 0.5rem; font-size: 0.875rem; color: #4b5563; }
        .radio-input { width: 1rem; height: 1rem; border-gray-300; }
        
        /* ë¬¸í•­ ì„ íƒ UI ê°œì„  */
        #questionCheckboxesContainer, .cross-analysis-likert-questions-container { /* êµì°¨ë¶„ì„ ë¦¬ì»¤íŠ¸ ë¬¸í•­ ì„ íƒ ì˜ì—­ì—ë„ ì ìš© */
            max-height: 22rem; /* Tailwind `max-h-88` (352px) */
            overflow-y: auto;
            border: 1px solid #cbd5e0; /* border-slate-300 */
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.75rem; /* p-3 */
            background-color: #f8fafc; /* bg-slate-50 */
            space-y: 0.5rem; /* Tailwind space-y-2 */
        }
        .question-item-label {
            display: block; /* ì „ì²´ ë„ˆë¹„ ì‚¬ìš© */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .question-summary { color: #6b7280; font-size: 0.8em; margin-left: 4px;}


        .likert-type-confirmation, .likert-group-confirmation { 
            border: 1px solid #e2e8f0; border-radius: 0.5rem; margin-bottom: 1rem;
            background-color: #f8fafc; padding: 1rem;
        }
        .likert-group-questions { 
            font-size: 0.8rem; color: #4a5568; margin-top: 0.5rem;
            padding-left: 1rem; max-height: 80px; overflow-y: auto;
        }
        .subjective-marker { /* Style for [ì£¼ê´€ì‹] marker */
            color: #64748b; /* slate-500 */
            font-weight: 500;
            margin-right: 4px;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px;
            border-radius: 50%; border-left-color: #09f;
            animation: spin 1s ease infinite; margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .question-text-row td {
            background-color: #e0e7ff !important; 
            font-weight: 600;
            color: #3730a3; 
        }
        .download-button { /* ê³µí†µ ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
            padding: 0.375rem 0.75rem; /* py-1.5 px-3 */
            border-radius: 0.375rem; /* rounded-md */
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* font-medium */
            margin-top: 0.75rem; /* mt-3 */
            transition: background-color 0.2s;
            margin-right: 0.5rem; /* ë²„íŠ¼ ê°„ ê°„ê²© */
        }
        .download-csv-button {
            background-color: #d1fae5; /* emerald-100 */
            color: #065f46; /* emerald-800 */
            border: 1px solid #6ee7b7; /* emerald-300 */
        }
        .download-csv-button:hover { background-color: #a7f3d0; /* emerald-200 */ }

        .download-png-button { /* PNG ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
            background-color: #fef3c7; /* amber-100 */
            color: #92400e; /* amber-800 */
            border: 1px solid #fcd34d; /* amber-300 */
        }
        .download-png-button:hover { background-color: #fde68a; /* amber-200 */ }
        
        .download-all-png-button { /* ì „ì²´ PNG ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
            background-color: #fed7aa; /* orange-300 */
            color: #9a3412; /* orange-700 */
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 500;
            transition: background-color 0.2s;
            border: 1px solid #fb923c; /* orange-400 */
        }
        .download-all-png-button:hover { background-color: #ffedd5; /* orange-200 */ }

        .chart-actions-container { /* ë²„íŠ¼ë“¤ì„ ë‹´ì„ ì»¨í…Œì´ë„ˆ */
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start; /* ì™¼ìª½ ì •ë ¬ */
            align-items: center; /* ë²„íŠ¼ê³¼ ì…€ë ‰íŠ¸ ìˆ˜ì§ ì •ë ¬ */
            margin-top: 0.5rem;
        }
        .individual-chart-type-select {
            margin-left: 0.5rem; /* PNG ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ê³¼ì˜ ê°„ê²© */
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #cbd5e0; /* slate-300 */
            font-size: 0.875rem;
            background-color: #f8fafc; /* slate-50 */
        }
        .color-swatch { 
            width: 12px; height: 12px; border-radius: 2px; 
            margin-right: 2px; border: 1px solid #ccc; display: inline-block;
        }
        .palette-selection-group { margin-bottom: 1rem; width:100%; } 
        h4[contenteditable="true"]:hover {
            background-color: #f0f9ff; /* sky-50 */
            outline: 1px dashed #38bdf8; /* sky-500 */
            cursor: text;
        }
        h4[contenteditable="true"]:focus {
            background-color: #e0f2fe; /* sky-100 */
            outline: 2px solid #0ea5e9; /* sky-600 */
        }

        /* ë ˆì´ë¸” í¸ì§‘ ëª¨ë‹¬ ìŠ¤íƒ€ì¼ */
        .label-edit-modal {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: white; padding: 2rem; border-radius: 0.75rem;
            box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            z-index: 100; max-height: 80vh; overflow-y: auto; min-width: 400px; max-width: 90vw;
        }
        .label-edit-modal ul { list-style: none; padding: 0; }
        .label-edit-modal li { 
            display: grid; grid-template-columns: 1fr 2fr; gap: 1rem; align-items: center;
            padding: 0.5rem 0; border-bottom: 1px solid #e5e7eb; 
        }
        .label-edit-modal li:last-child { border-bottom: none; }
        .label-edit-modal .original-label-text { font-size: 0.875rem; color: #6b7280; /* gray-500 */ white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .label-edit-modal .custom-label-input { 
            width: 100%; padding: 0.375rem 0.5rem; border: 1px solid #d1d5db; /* gray-300 */
            border-radius: 0.25rem; font-size: 0.875rem;
        }
        .label-edit-modal .custom-label-input:disabled { background-color: #f3f4f6; /* gray-100 */ color: #9ca3af; /* gray-400 */ }
        .label-edit-modal .modal-actions { margin-top: 1.5rem; text-align: right; }
        .label-edit-modal .modal-actions button {
            padding: 0.5rem 1rem; border-radius: 0.375rem; font-weight: 500;
            margin-left: 0.5rem;
        }
        .label-edit-modal .modal-actions .apply-btn { background-color: #2563eb; color: white; }
        .label-edit-modal .modal-actions .apply-btn:hover { background-color: #1d4ed8; }
        .label-edit-modal .modal-actions .cancel-btn { background-color: #e5e7eb; color: #374151; }
        .label-edit-modal .modal-actions .cancel-btn:hover { background-color: #d1d5db; }
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5); z-index: 99;
        }

    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-slate-100 text-slate-800">
    <header class="bg-gradient-to-r from-sky-600 to-cyan-500 text-white p-6 shadow-xl">
        <h1 class="text-3xl font-bold text-center tracking-tight">ğŸ“Š ì—‘ì…€ ë¬¸í•­ ë¶„ì„ ë° ì‹œê°í™” ë„êµ¬</h1>
        <p class="text-center text-sm mt-1 opacity-90">ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê³ , ë¬¸í•­ë³„ ë‹µë³€ ë¶„í¬ ë° êµì°¨ ë¶„ì„ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”.</p>
        <div id="buildInfo" class="text-center text-xs mt-2 opacity-75"></div>
    </header>

    <main class="container mx-auto mt-10 p-5 space-y-10">
        <section id="fileUploadSection" class="bg-white p-8 rounded-xl shadow-2xl transition-all duration-300 hover:shadow-blue-200/50">
            <h2 class="section-header"><span class="text-sky-600">ë‹¨ê³„ 1:</span> ì—‘ì…€ íŒŒì¼ ì„ íƒ</h2>
            <input type="file" id="excelFile" accept=".xlsx, .xls, .csv" class="hidden">
            <button id="selectFileBtn" type="button" class="bg-sky-500 hover:bg-sky-600 text-white font-medium py-3 px-6 rounded-lg transition-colors shadow hover:shadow-md">
                ğŸ“ íŒŒì¼ ì„ íƒí•˜ê¸°
            </button>
            <span id="fileNameDisplay" class="ml-4 text-sm text-slate-600">ì„ íƒëœ íŒŒì¼ ì—†ìŒ</span>
            <div id="loadingSpinner" class="spinner hidden"></div>
            <p class="text-xs text-slate-500 mt-3">ì§€ì› íŒŒì¼ í˜•ì‹: .xlsx, .xls, .csv. íŒŒì¼ì˜ ì²« ë²ˆì§¸ ì‹œíŠ¸ê°€ ì‚¬ìš©ë©ë‹ˆë‹¤.</p>
            <div id="fileErrorDisplay" class="text-red-500 text-sm mt-2"></div>
        </section>

        <section id="dataDisplaySection" class="bg-white p-8 rounded-xl shadow-2xl transition-all duration-300 hover:shadow-blue-200/50 hidden">
            <h2 class="section-header"><span class="text-sky-600">ë‹¨ê³„ 2:</span> ì›ë³¸ ë°ì´í„° í™•ì¸</h2>
            <div id="dataTableContainer" class="max-h-[450px] overflow-auto border border-slate-300 rounded-lg shadow-inner bg-slate-50">
                <p class="p-6 text-center text-slate-500">ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ë°ì´í„°ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</p>
            </div>
        </section>

        <section id="likertDefinitionSection" class="bg-white p-8 rounded-xl shadow-2xl transition-all duration-300 hover:shadow-blue-200/50 hidden">
            <h2 class="section-header"><span class="text-sky-600">ë‹¨ê³„ 2-1:</span> ë¦¬ì»¤íŠ¸ ì²™ë„ ë° ì§ˆë¬¸ í–‰ ì„¤ì •</h2>
            
            <div class="w-full mb-6"> 
                <label for="questionTextRow" class="block text-sm font-medium text-slate-700 mb-1.5">ì§ˆë¬¸ í…ìŠ¤íŠ¸ê°€ ìˆëŠ” í–‰ ë²ˆí˜¸ (ì„ íƒ ì‚¬í•­):</label>
                <input type="number" id="questionTextRow" value="2" min="1" class="w-full md:w-1/2 p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-sky-500 focus:border-sky-500">
                <p class="text-xs text-slate-500 mt-1.5">ì—‘ì…€ ì‹œíŠ¸ì—ì„œ ì‹¤ì œ ì§ˆë¬¸ ë‚´ìš©ì´ ì íŒ í–‰ì˜ ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: 2í–‰). ì²« í–‰ì€ í—¤ë”(ë¬¸í•­ ì œëª©)ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤. ë¹„ì›Œë‘ë©´ ì—´ ì œëª©ì„ ì§ˆë¬¸ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.</p>
            </div>

            <p id="likertInfoText" class="text-sm text-slate-600 mb-4">
                ë°ì´í„°ì—ì„œ ë¦¬ì»¤íŠ¸ ì²™ë„ë¡œ ë³´ì´ëŠ” ë‹µë³€ ìœ í˜•ì´ ë°œê²¬ë˜ë©´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤. í•´ë‹¹ ìœ í˜•ì˜ ë¬¸í•­ë“¤ì— ëŒ€í•´ 5ì  ì²™ë„ ë¶„ì„ ê·œì¹™(ì •ë ¬, ìƒ‰ìƒ, í‰ê·  ì ìˆ˜ ë“±)ì„ ì ìš©í• ì§€ ì„ íƒí•´ì£¼ì„¸ìš”.
            </p>
            <div id="likertDefinitionContainer" class="space-y-4">
                {/* ë¦¬ì»¤íŠ¸ ì²™ë„ ì„ íƒ UIê°€ ë™ì ìœ¼ë¡œ ì—¬ê¸°ì— ì¶”ê°€ë©ë‹ˆë‹¤. */}
            </div>
            <div class="mt-6 text-center">
                <button id="proceedToStep3Btn" type="button" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-6 rounded-md transition-colors">
                    ë‹¤ìŒ ë‹¨ê³„ë¡œ (ë¶„ì„ ì„¤ì •) &rarr;
                </button>
            </div>
        </section>

        <section id="graphConfigSection" class="bg-white p-8 rounded-xl shadow-2xl transition-all duration-300 hover:shadow-blue-200/50 hidden">
            <h2 class="section-header"><span class="text-sky-600">ë‹¨ê³„ 3:</span> ë¶„ì„ ì„¤ì •</h2>
            <div id="basicAnalysisConfig">
                <h3 class="subsection-header">3-1: ê¸°ë³¸ ë¬¸í•­ ë¶„ì„</h3>
                <div class="grid md:grid-cols-2 gap-x-8 gap-y-6">
                    <div>
                        <label class="block text-sm font-medium text-slate-700 mb-1.5">ë¶„ì„í•  ë¬¸í•­ ì„ íƒ (ì—´ ì œëª© ê¸°ì¤€):</label>
                        <div class="flex items-center mb-2">
                            <input type="checkbox" id="selectAllQuestions" class="h-4 w-4 rounded border-gray-300 text-sky-600 focus:ring-sky-500">
                            <label for="selectAllQuestions" class="ml-2 block text-sm text-slate-900">ì „ì²´ ë¬¸í•­ ì„ íƒ/í•´ì œ</label>
                        </div>
                        <div class="flex items-center mb-2">
                            <input type="checkbox" id="deselectSubjectiveCheckbox" class="h-4 w-4 rounded border-gray-300 text-sky-600 focus:ring-sky-500" checked>
                            <label for="deselectSubjectiveCheckbox" class="ml-2 block text-sm text-slate-900">ì£¼ê´€ì‹ ë¬¸í•­ ìë™ ì„ íƒ í•´ì œ</label>
                        </div>
                        <div id="questionCheckboxesContainer" class="max-h-88 overflow-y-auto space-y-2 p-3 border rounded-md bg-slate-50 border-slate-300"> 
                            <p class="text-sm text-slate-400">íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ì—¬ê¸°ì— ë¬¸í•­ ëª©ë¡ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.</p>
                        </div>
                    </div>
                    <div>
                        <div class="w-full mb-4"> 
                            <label for="chartType" class="block text-sm font-medium text-slate-700 mb-1.5">ê°ê´€ì‹ ë¬¸í•­ ê·¸ë˜í”„ ì¢…ë¥˜:</label>
                            <select id="chartType" class="w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-sky-500 focus:border-sky-500 appearance-none bg-white">
                                <option value="bar">ğŸ“Š ì„¸ë¡œ ë¹„ìœ¨ ë§‰ëŒ€</option>
                                <option value="horizontalBar">ğŸ“Š ê°€ë¡œ ë¹„ìœ¨ ë§‰ëŒ€</option>
                                <option value="stackedBar">ğŸ“¶ ì„¸ë¡œ ì „ì²´ ëˆ„ì </option> 
                                <option value="stackedHorizontalBar">â†”ï¸ ê°€ë¡œ ì „ì²´ ëˆ„ì </option> 
                                <option value="pie">ğŸ¥§ ì›í˜•</option>
                                <option value="doughnut">ğŸ© ë„ë„›í˜•</option>
                            </select>
                            <p class="text-xs text-slate-500 mt-1.5">ê°ê´€ì‹ ë‹µë³€ ë¶„í¬ë¥¼ ë‚˜íƒ€ë‚¼ ê·¸ë˜í”„ í˜•íƒœë¥¼ ì„ íƒí•˜ì„¸ìš”. (ì£¼ê´€ì‹ì€ ì‘ë‹µ ëª©ë¡ìœ¼ë¡œ í‘œì‹œ)</p>
                        </div>
                        
                        <div class="w-full palette-selection-group mb-4"> 
                            <label class="block text-sm font-medium text-slate-700 mb-1.5">ë¦¬ì»¤íŠ¸ ì²™ë„ìš© ìƒ‰ìƒ íŒ”ë ˆíŠ¸:</label>
                            <div id="likertColorPaletteSelector" class="space-y-2">
                                {/* ë¼ë””ì˜¤ ë²„íŠ¼ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤. */}
                            </div>
                        </div>
                        <div class="w-full palette-selection-group"> 
                            <label class="block text-sm font-medium text-slate-700 mb-1.5">ì¼ë°˜ ì°¨íŠ¸ìš© ìƒ‰ìƒ íŒ”ë ˆíŠ¸:</label>
                            <div id="generalColorPaletteSelector" class="space-y-2">
                                {/* ë¼ë””ì˜¤ ë²„íŠ¼ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤. */}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="crossAnalysisSectionsContainer" class="mt-8 space-y-6">
                <div id="crossAnalysisConfig-0" class="cross-analysis-section">
                    <button id="toggleCrossAnalysisBtn-0" type="button" class="toggle-button w-full text-left mb-3">
                        <span><span class="toggle-icon inline-block transform transition-transform duration-200">&#9654;</span> <span class="section-index">3-2:</span> êµì°¨ ë¶„ì„ ì„¤ì • (í–‰ë ¬í˜• ë¦¬ì»¤íŠ¸)</span>
                    </button>
                    <div id="crossAnalysisSettings-0" class="cross-analysis-settings hidden p-6 border border-dashed border-slate-300 rounded-lg bg-slate-50">
                        <p class="text-sm text-slate-600 mb-4">ë™ì¼í•œ ì‘ë‹µ ìœ í˜•ì„ ê°€ì§„ ì—¬ëŸ¬ ë¦¬ì»¤íŠ¸ ì²™ë„ ë¬¸í•­ë“¤ì˜ í‰ê·  ì ìˆ˜ ë˜ëŠ” ì‘ë‹µ ë¹„ìœ¨ì„ ê·¸ë£¹ë³„ë¡œ ë¹„êµí•©ë‹ˆë‹¤.</p>
                        <div class="grid md:grid-cols-2 gap-x-8 gap-y-4">
                            <div>
                                <label class="block text-sm font-medium text-slate-700 mb-1.5">ë¹„êµí•  ë¦¬ì»¤íŠ¸ ë¬¸í•­ë“¤ (ë‹¤ì¤‘ ì„ íƒ):</label>
                                <div id="crossAnalysisLikertQuestions-0" class="cross-analysis-likert-questions-container">
                                    <p class="text-sm text-slate-400">íŒŒì¼ ì—…ë¡œë“œ í›„ ë¦¬ì»¤íŠ¸ ë¬¸í•­ì´ ê°ì§€ë˜ë©´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</p>
                                </div>
                            </div>
                            <div>
                                <div class="mb-4">
                                    <label for="crossAnalysisGroupingQuestion-0" class="block text-sm font-medium text-slate-700 mb-1.5">ê·¸ë£¹í™” ê¸°ì¤€ ë¬¸í•­ (ê°ê´€ì‹):</label>
                                    <select id="crossAnalysisGroupingQuestion-0" class="crossAnalysisGroupingQuestion w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-sky-500 focus:border-sky-500 appearance-none bg-white">
                                        <option value="">-- ë¬¸í•­ ì„ íƒ --</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="crossAnalysisChartType-0" class="block text-sm font-medium text-slate-700 mb-1.5">êµì°¨ ë¶„ì„ ì°¨íŠ¸ ìœ í˜•:</label>
                                    <select id="crossAnalysisChartType-0" class="crossAnalysisChartType w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-sky-500 focus:border-sky-500 appearance-none bg-white">
                                        <option value="averageScoreBar" selected>í‰ê·  ì ìˆ˜ ë¹„êµ (ê·¸ë£¹ ë§‰ëŒ€)</option>
                                        <option value="stackedPercentageBar">100% ëˆ„ì  ë¹„ìœ¨ ë§‰ëŒ€ (ê·¸ë£¹í˜•)</option>
                                        <option value="overallAverageScoreBar">ê°œë³„ ë¬¸í•­ ì „ì²´ í‰ê·  ë¹„êµ</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
             </div>

            <div class="mt-6 text-right">
                <button id="addCrossAnalysisBtn" type="button" class="bg-sky-100 text-sky-700 font-medium py-2 px-4 rounded-md hover:bg-sky-200 transition-colors">
                    + êµì°¨ ë¶„ì„ ì¶”ê°€
                </button>
            </div>

            <div class="mt-10 text-center">
                <button id="generateChartBtn" type="button" class="bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white font-semibold py-3.5 px-10 rounded-lg shadow-lg hover:shadow-xl transform hover:scale-105 transition duration-300 ease-in-out focus:outline-none focus:ring-4 focus:ring-green-300">
                    ğŸš€ ë¶„ì„ ë° ì‹œê°í™” ìƒì„±
                </button>
            </div>
        </section>

        <section id="chartDisplaySection" class="bg-transparent p-0 md:p-4 rounded-xl shadow-none hidden">
             <div class="flex justify-between items-center bg-white p-6 rounded-t-xl md:rounded-xl mb-0 md:mb-6">
                <h2 class="section-header !mb-0 !border-b-0"><span class="text-sky-600">ë‹¨ê³„ 4:</span> ë¶„ì„ ê²°ê³¼</h2>
                <button id="downloadAllPngBtn" type="button" class="download-all-png-button hidden">
                    ğŸ–¼ï¸ ì „ì²´ ì°¨íŠ¸ PNGë¡œ ë‹¤ìš´ë¡œë“œ (ZIP)
                </button>
            </div>
            <div id="chartsAreaContainer" class="bg-white p-6 rounded-b-xl md:rounded-xl shadow-2xl">
                <div id="chartsArea">
                </div>
            </div>
            <div id="noDataMessage" class="text-center text-slate-500 py-12 bg-white p-6 rounded-xl shadow-2xl hidden">
                <svg class="mx-auto h-16 w-16 text-slate-400" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M11.25 11.25l.041-.02a.75.75 0 011.063.852l-.708 2.836a.75.75 0 001.063.853l.041-.021M21 12a9 9 0 11-18 0 9 9 0 0118 0zm-9-3.75h.008v.008H12V8.25z" />
                </svg>
                <h3 class="mt-4 text-lg font-semibold text-slate-800">ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</h3>
                <p class="mt-1.5 text-sm text-slate-500">ì„ íƒí•˜ì‹  ì¡°ê±´ìœ¼ë¡œ ì‹œê°í™”í•  ìˆ˜ ìˆëŠ” ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. <br>íŒŒì¼, ì„ íƒëœ ë¬¸í•­, ì§ˆë¬¸ í…ìŠ¤íŠ¸ í–‰ ë²ˆí˜¸ë¥¼ ë‹¤ì‹œ í™•ì¸í•´ì£¼ì„¸ìš”.</p>
            </div>
        </section>
    </main>

    <footer class="text-center p-8 mt-16 text-sm text-slate-500 border-t border-slate-200">
        &copy; <span id="currentYear"></span> ë¬¸í•­ ë¶„ì„ ë„êµ¬. All rights reserved.
    </footer>

    <script>
        // --- Global Variables ---
        let rawExcelData = []; 
        let excelDataForAnalysis = []; 
        let excelHeaders = []; 
        let questionFullTexts = {}; 
        let questionTextRowIndex = -1; 
        let dataStartRowIndex = 1; 
        let questionTypes = {}; // { qHeader: 'likert' | 'subjective' | 'objective', ... }

        let crossAnalysisSectionCounter = 0; 
        // activeCharts will store objects: { instance: ChartInstance, questionHeader: String, type: 'basic'|'cross'|'matrix', originalCanvas: HTMLCanvasElement, chartData: {}, originalTitle: String, customTitle: String, crossChartType?: String, groupingQuestion?: String, likertQuestions?: Array<String>, customLabels?: object }
        let activeCharts = []; 
        
        const LIKERT_SCALES = {
            satisfaction_5: {
                id: "satisfaction_5", name: "5ì  ë§Œì¡±ë„ (ë§¤ìš° ë§Œì¡± ~ ë§¤ìš° ë¶ˆë§Œì¡±)",
                positive_keywords: ["ë§Œì¡±"],
                negative_keywords: ["ë¶ˆë§Œì¡±"],
                intensifiers: ["ë§¤ìš°", "ë‹¤ì†Œ", "ì•½ê°„", "ì „í˜€", "ë³„ë¡œ"], 
                responses: ["ë§¤ìš° ë§Œì¡±", "ë§Œì¡±", "ë³´í†µ", "ë¶ˆë§Œì¡±", "ë§¤ìš° ë¶ˆë§Œì¡±"],
                scores: [5, 4, 3, 2, 1],
                colors: ['#15803d', '#65a30d', '#FAFAD2', '#e11d48', '#b91c1c'] 
            },
            agreement_5: {
                id: "agreement_5", name: "5ì  ë™ì˜ë„ (ë§¤ìš° ê·¸ë ‡ë‹¤ ~ ì „í˜€ ì•„ë‹ˆë‹¤)",
                positive_keywords: ["ê·¸ë ‡ë‹¤", "ë™ì˜í•œë‹¤", "ë™ì˜"],
                negative_keywords: ["ì•„ë‹ˆë‹¤", "ë™ì˜í•˜ì§€ ì•ŠëŠ”ë‹¤"],
                intensifiers: ["ë§¤ìš°", "ë‹¤ì†Œ", "ì•½ê°„", "ì „í˜€", "ë³„ë¡œ"],
                responses: ["ë§¤ìš° ê·¸ë ‡ë‹¤", "ê·¸ë ‡ë‹¤", "ë³´í†µì´ë‹¤", "ì•„ë‹ˆë‹¤", "ì „í˜€ ì•„ë‹ˆë‹¤"],
                scores: [5, 4, 3, 2, 1],
                colors: ['#15803d', '#65a30d', '#FAFAD2', '#e11d48', '#b91c1c'] 
            },
             agreement_5_v2: { 
                id: "agreement_5_v2", name: "5ì  ë™ì˜ë„ (ë§¤ìš° ê·¸ë ‡ë‹¤ ~ ì „í˜€ ê·¸ë ‡ì§€ ì•Šë‹¤)",
                positive_keywords: ["ê·¸ë ‡ë‹¤", "ë™ì˜í•œë‹¤", "ë™ì˜"],
                negative_keywords: ["ê·¸ë ‡ì§€ ì•Šë‹¤", "ë™ì˜í•˜ì§€ ì•ŠëŠ”ë‹¤"],
                intensifiers: ["ë§¤ìš°", "ë‹¤ì†Œ", "ì•½ê°„", "ì „í˜€", "ë³„ë¡œ"],
                responses: ["ë§¤ìš° ê·¸ë ‡ë‹¤", "ê·¸ë ‡ë‹¤", "ë³´í†µ", "ê·¸ë ‡ì§€ ì•Šë‹¤", "ì „í˜€ ê·¸ë ‡ì§€ ì•Šë‹¤"],
                scores: [5, 4, 3, 2, 1],
                colors: ['#15803d', '#65a30d', '#FAFAD2', '#e11d48', '#b91c1c'] 
            },
            agreement_5_v3: { 
                id: "agreement_5_v3", name: "5ì  ë™ì˜ë„ (ë§¤ìš° ë™ì˜í•¨ ~ ì „í˜€ ë™ì˜í•˜ì§€ ì•ŠìŒ)",
                positive_keywords: ["ë™ì˜í•¨", "ë™ì˜í•œë‹¤"], 
                negative_keywords: ["ë™ì˜í•˜ì§€ ì•ŠìŒ", "ë™ì˜í•˜ì§€ ì•ŠëŠ”ë‹¤"],
                intensifiers: ["ë§¤ìš°", "ë‹¤ì†Œ", "ì „í˜€"], 
                responses: ["ë§¤ìš° ë™ì˜í•¨", "ë‹¤ì†Œ ë™ì˜í•¨", "ë³´í†µ", "ë‹¤ì†Œ ë™ì˜í•˜ì§€ ì•ŠìŒ", "ì „í˜€ ë™ì˜í•˜ì§€ ì•ŠìŒ"],
                scores: [5, 4, 3, 2, 1],
                colors: ['#166534', '#15803d', '#FAFAD2', '#ef4444', '#b91c1c'] 
            },
            improvement_5: {
                id: "improvement_5", name: "5ì  ë³€í™” (ëˆˆì— ë„ê²Œ ë” ì¢‹ì•„ì§ ~ ëˆˆì— ë„ê²Œ ë” ë‚˜ë¹ ì§)",
                positive_keywords: ["ì¢‹ì•„ì§", "ì¢‹ì•„ì¡Œë‹¤"],
                negative_keywords: ["ë‚˜ë¹ ì§", "ë‚˜ë¹ ì¡Œë‹¤"],
                intensifiers: ["ëˆˆì— ë„ê²Œ", "ë¯¸ë¯¸í•˜ê²Œ", "ë‹¤ì†Œ", "ê±°ì˜"],
                neutral_keywords: ["ë³€í•¨ ì—†ìŒ", "ë³€í•˜ì§€ ì•ŠìŒ"],
                responses: ["ëˆˆì— ë„ê²Œ ë” ì¢‹ì•„ì§", "ë¯¸ë¯¸í•˜ê²Œ ë” ì¢‹ì•„ì§", "ê±°ì˜ ë³€í•¨ ì—†ìŒ", "ë¯¸ë¯¸í•˜ê²Œ ë” ë‚˜ë¹ ì§", "ëˆˆì— ë„ê²Œ ë” ë‚˜ë¹ ì§"],
                scores: [5, 4, 3, 2, 1], 
                colors: ['#15803d', '#84cc16', '#FAFAD2', '#fb7185', '#e11d48']
            },
            agreement_numeric_desc: {
                id: "agreement_numeric_desc", name: "5ì  ë™ì˜ë„ (1ì  ì „í˜€ ê·¸ë ‡ì§€ ì•Šë‹¤ ~ 5ì  ë§¤ìš° ê·¸ë ‡ë‹¤)",
                positive_keywords: ["ê·¸ë ‡ë‹¤", "ë™ì˜"],
                negative_keywords: ["ê·¸ë ‡ì§€ ì•Šë‹¤"],
                intensifiers: ["ë§¤ìš°", "ì „í˜€"],
                responses: ["5 (ë§¤ìš° ê·¸ë ‡ë‹¤)", "4 (ê·¸ë ‡ë‹¤)", "3 (ë³´í†µ)", "2 (ê·¸ë ‡ì§€ ì•Šë‹¤)", "1 (ì „í˜€ ê·¸ë ‡ì§€ ì•Šë‹¤)"],
                scores: [5, 4, 3, 2, 1],
                colors: ['#15803d', '#65a30d', '#FAFAD2', '#ef4444', '#b91c1c']
            },
            satisfaction_numeric_desc: {
                id: "satisfaction_numeric_desc", name: "5ì  ë§Œì¡±ë„ (1ì  ë§¤ìš° ë¶ˆë§Œì¡± ~ 5ì  ë§¤ìš° ë§Œì¡±)",
                positive_keywords: ["ë§Œì¡±"],
                negative_keywords: ["ë¶ˆë§Œì¡±"],
                intensifiers: ["ë§¤ìš°"],
                responses: ["5 (ë§¤ìš° ë§Œì¡±)", "4 (ë§Œì¡±)", "3 (ë³´í†µ)", "2 (ë¶ˆë§Œì¡±)", "1 (ë§¤ìš° ë¶ˆë§Œì¡±)"],
                scores: [5, 4, 3, 2, 1],
                colors: ['#15803d', '#65a30d', '#FAFAD2', '#ef4444', '#b91c1c']
            },
            fun_5_v2: { 
                id: "fun_5_v2", name: "5ì  ì¬ë¯¸ (ë§¤ìš° ì¬ë¯¸ìˆìŒ ~ ë§¤ìš° ì¬ë¯¸ì—†ìŒ)",
                positive_keywords: ["ì¬ë¯¸ìˆìŒ"],
                negative_keywords: ["ì¬ë¯¸ì—†ìŒ"],
                intensifiers: ["ë§¤ìš°", "ë‹¤ì†Œ", "ë³„ë¡œ"],
                responses: ["ë§¤ìš° ì¬ë¯¸ìˆìŒ", "ë‹¤ì†Œ ì¬ë¯¸ìˆìŒ", "ë³´í†µ", "ë‹¤ì†Œ ì¬ë¯¸ì—†ìŒ", "ë§¤ìš° ì¬ë¯¸ì—†ìŒ"],
                scores: [5, 4, 3, 2, 1],
                colors: ['#15803d', '#65a30d', '#FAFAD2', '#ef4444', '#b91c1c']
            }
        };
        let detectedLikertQuestions = {}; 
        let userLikertChoices = {}; 
        const SUBJECTIVE_UNIQUE_RESPONSE_THRESHOLD = 10; 
        const OTHER_RESPONSE_LABEL = "ê¸°íƒ€"; 
        const OTHER_RESPONSE_COLOR = '#A9A9A9'; // DarkGray
        const NO_RESPONSE_COLOR = '#D3D3D3';   // LightGray
        const NO_RESPONSE_TERMS = ["ì‘ë‹µ ì—†ìŒ", "ê²½í—˜ ì—†ìŒ", "ë¬´ì‘ë‹µ", "í•´ë‹¹ ì—†ìŒ", "N/A", "n/a", "-", "", "ë“¤ì–´ë³¸ ì  ì—†ìŒ"];


        const COLOR_PALETTES = {
            likert: {
                palette1: ['#2563eb', '#60a5fa', '#FAFAD2', '#fb7185', '#e11d48'], 
                default: LIKERT_SCALES.agreement_5_v3.colors, 
            },
            general: {
                default: ['#0891b2', '#0ea5e9', '#6366f1', '#a855f7', '#ec4899', '#f43f5e', '#f59e0b', '#eab308', '#84cc16', '#22c55e'], 
                palette1: ['#4f46e5', '#7c3aed', '#db2777', '#f59e0b', '#10b981', '#06b6d4', '#ef4444', '#65a30d', '#9333ea', '#e11d48'],
                palette2: ['#57534e', '#78716c', '#a1a1aa', '#d4d4d8', '#a3a3a3', '#082f49', '#164e63', '#0e7490', '#0369a1', '#0ea5e9'],
            }
        };
        let currentLikertPaletteKey = 'palette1'; 
        let currentGeneralPaletteKey = 'default';

        const PALETTE_NAMES = {
            likert: {
                palette1: "ë¦¬ì»¤íŠ¸ ê¸°ë³¸ê°’ (íŒŒë‘-ë…¸ë‘-ë¹¨ê°•)",
                default: "ë¦¬ì»¤íŠ¸ íŒ”ë ˆíŠ¸ 1 (ì²™ë„ë³„ ì •ì˜)",
            },
            general: {
                default: "ì¼ë°˜ ê¸°ë³¸ê°’",
                palette1: "ì¼ë°˜ íŒ”ë ˆíŠ¸ 1",
                palette2: "ì¼ë°˜ íŒ”ë ˆíŠ¸ 2",
            }
        };


        // --- DOM Elements ---
        const excelFileInput = document.getElementById('excelFile');
        const selectFileBtn = document.getElementById('selectFileBtn');
        const fileNameDisplay = document.getElementById('fileNameDisplay');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const fileErrorDisplay = document.getElementById('fileErrorDisplay');
        const dataDisplaySection = document.getElementById('dataDisplaySection');
        const dataTableContainer = document.getElementById('dataTableContainer');
        const likertDefinitionSection = document.getElementById('likertDefinitionSection');
        const likertInfoText = document.getElementById('likertInfoText');
        const likertDefinitionContainer = document.getElementById('likertDefinitionContainer');
        const proceedToStep3Btn = document.getElementById('proceedToStep3Btn');
        const graphConfigSection = document.getElementById('graphConfigSection');
        const questionCheckboxesContainer = document.getElementById('questionCheckboxesContainer');
        const selectAllQuestionsCheckbox = document.getElementById('selectAllQuestions'); 
        const deselectSubjectiveCheckbox = document.getElementById('deselectSubjectiveCheckbox'); 
        const questionTextRowInput = document.getElementById('questionTextRow'); 
        const chartTypeSelect = document.getElementById('chartType');
        const likertColorPaletteSelector = document.getElementById('likertColorPaletteSelector'); 
        const generalColorPaletteSelector = document.getElementById('generalColorPaletteSelector');
        const crossAnalysisSectionsContainer = document.getElementById('crossAnalysisSectionsContainer'); 
        const addCrossAnalysisBtn = document.getElementById('addCrossAnalysisBtn');
        const generateChartBtn = document.getElementById('generateChartBtn');
        const chartDisplaySection = document.getElementById('chartDisplaySection');
        const chartsArea = document.getElementById('chartsArea'); 
        const noDataMessage = document.getElementById('noDataMessage');
        const downloadAllPngBtn = document.getElementById('downloadAllPngBtn'); 


        Chart.defaults.font.family = 'Inter, sans-serif';
        Chart.defaults.plugins.legend.position = 'bottom';
        Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(0,0,0,0.7)';
        Chart.defaults.plugins.tooltip.titleFont = { weight: 'bold', size: 14 };
        Chart.defaults.plugins.tooltip.bodyFont = { size: 12 };
        Chart.defaults.responsive = true;
        Chart.defaults.maintainAspectRatio = false;
        Chart.register(ChartDataLabels); 

        document.getElementById('currentYear').textContent = new Date().getFullYear();

        // --- Event Listeners ---
        selectFileBtn.addEventListener('click', () => { excelFileInput.value = null; fileErrorDisplay.textContent = ''; excelFileInput.click(); });
        excelFileInput.addEventListener('change', handleFileUpload);
        proceedToStep3Btn.addEventListener('click', handleProceedToStep3);
        addCrossAnalysisBtn.addEventListener('click', addNewCrossAnalysisSection);
        const initialToggleButton = document.getElementById('toggleCrossAnalysisBtn-0');
        if (initialToggleButton) initialToggleButton.addEventListener('click', toggleCrossAnalysisSection);
        generateChartBtn.addEventListener('click', generateChartsFromSelection);
        
        selectAllQuestionsCheckbox.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            const deselectSubjective = deselectSubjectiveCheckbox.checked;
            questionCheckboxesContainer.querySelectorAll('.question-item-checkbox').forEach(cb => {
                const questionHeader = cb.value;
                const isSubjective = questionTypes[questionHeader] === 'subjective';
                if (isChecked) {
                    if (deselectSubjective && isSubjective) {
                        cb.checked = false; 
                    } else {
                        cb.checked = true;
                    }
                } else {
                    cb.checked = false; 
                }
            });
        });

        deselectSubjectiveCheckbox.addEventListener('change', (e) => {
            const deselectSubjectiveIsOn = e.target.checked;
            if (deselectSubjectiveIsOn) {
                questionCheckboxesContainer.querySelectorAll('.question-item-checkbox').forEach(cb => {
                    const questionHeader = cb.value;
                    const isSubjective = questionTypes[questionHeader] === 'subjective';
                    if (isSubjective) {
                        cb.checked = false;
                    }
                });
            } else {
                if (selectAllQuestionsCheckbox.checked) {
                    questionCheckboxesContainer.querySelectorAll('.question-item-checkbox').forEach(cb => {
                         const questionHeader = cb.value;
                         const isSubjective = questionTypes[questionHeader] === 'subjective';
                         if (isSubjective) { 
                             cb.checked = true;
                         }
                    });
                }
            }
        });


        questionTextRowInput.addEventListener('change', handleQuestionRowChange);
        downloadAllPngBtn.addEventListener('click', downloadAllChartsAsPngZip); 

        // --- Helper Function to format numbers with commas ---
        function formatNumberWithCommas(number) {
            return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }
        
        // --- Helper function to truncate text ---
        function truncateText(text, maxLength) {
            if (text && text.length > maxLength) {
                return text.substring(0, maxLength) + "...";
            }
            return text;
        }


        // --- Helper Functions for Color and Luminosity ---
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function isColorLight(hexColor) {
            if (!hexColor || typeof hexColor !== 'string') return true; 
            const rgb = hexToRgb(hexColor);
            if (!rgb) return true; 
            const brightness = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b);
            return brightness > 128; 
        }


        // --- Core Functions ---
        function stripHtmlTags(str) { if (str === null || str === '' || typeof str === 'undefined') return ''; return String(str).replace(/<[^>]*>/g, ''); }
        
        function processRawExcelData(data) {
            if (data.length === 0) { excelHeaders = []; questionFullTexts = {}; excelDataForAnalysis = []; questionTextRowIndex = -1; dataStartRowIndex = 1; questionTypes = {}; return; }
            excelHeaders = data[0].map(String); 
            questionFullTexts = {}; questionTypes = {};
            const qTextRowInputVal = questionTextRowInput.value.trim();
            let parsedQTextRow = -1; 
            if (qTextRowInputVal !== "") parsedQTextRow = parseInt(qTextRowInputVal, 10);
            questionTextRowIndex = (parsedQTextRow > 0 && parsedQTextRow <= data.length && parsedQTextRow !== 1) ? parsedQTextRow - 1 : -1;
            dataStartRowIndex = (questionTextRowIndex !== -1 && questionTextRowIndex > 0) ? questionTextRowIndex + 1 : 1;

            if (questionTextRowIndex !== -1 && data.length > questionTextRowIndex) { 
                const textRowData = data[questionTextRowIndex];
                excelHeaders.forEach((h, i) => { questionFullTexts[h] = textRowData[i] ? stripHtmlTags(String(textRowData[i])).trim() : stripHtmlTags(String(h)); });
            } else { excelHeaders.forEach(h => { questionFullTexts[h] = stripHtmlTags(String(h)); }); }
            
            excelDataForAnalysis = (data.length > dataStartRowIndex) ? data.slice(dataStartRowIndex).map(rA => { const rO = {}; excelHeaders.forEach((h, i) => { rO[h] = rA[i]; }); return rO; }) : [];

            excelHeaders.forEach(qHeader => {
                const uniqueResponses = new Set();
                excelDataForAnalysis.forEach(row => {
                     if (row[qHeader] !== undefined && row[qHeader] !== null && String(row[qHeader]).trim() !== "") {
                        uniqueResponses.add(String(row[qHeader]).trim());
                    }
                });
                if (uniqueResponses.size > SUBJECTIVE_UNIQUE_RESPONSE_THRESHOLD) {
                    questionTypes[qHeader] = 'subjective';
                } else {
                    questionTypes[qHeader] = 'objective'; 
                }
            });
        }

        async function handleFileUpload(event) {
            const file = event.target.files[0]; if (!file) { fileNameDisplay.textContent = 'ì„ íƒëœ íŒŒì¼ ì—†ìŒ'; return; }
            fileNameDisplay.textContent = file.name; loadingSpinner.classList.remove('hidden'); fileErrorDisplay.textContent = '';
            [dataDisplaySection, likertDefinitionSection, graphConfigSection, chartDisplaySection].forEach(s => s.classList.add('hidden'));
            dataTableContainer.innerHTML = '<p class="p-6 text-center text-slate-500">ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>';
            detectedLikertQuestions = {}; userLikertChoices = {}; questionTypes = {};
            downloadAllPngBtn.classList.add('hidden'); 

            try {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const fileData = new Uint8Array(e.target.result); const workbook = XLSX.read(fileData, { type: 'array', cellDates: true }); 
                        const firstSheetName = workbook.SheetNames[0]; if (!firstSheetName) throw new Error("ì—‘ì…€ íŒŒì¼ì— ì‹œíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.");
                        const worksheet = workbook.Sheets[firstSheetName]; rawExcelData = XLSX.utils.sheet_to_json(worksheet, { header: 1, raw: false, defval: '' });
                        if (rawExcelData.length === 0) throw new Error("ì—‘ì…€ ì‹œíŠ¸ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                        processRawExcelData(rawExcelData); 
                        displayDataTable(excelHeaders, rawExcelData.slice(0, 50), questionTextRowIndex); 
                        populateQuestionSelectors(excelHeaders, questionFullTexts, questionTypes); 
                        detectAndDisplayLikertOptions(); 
                        dataDisplaySection.classList.remove('hidden'); dataDisplaySection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    } catch (parseError) { console.error("Error parsing Excel data:", parseError); fileErrorDisplay.textContent = `íŒŒì¼ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${parseError.message}`; dataTableContainer.innerHTML = '<p class="p-6 text-center text-red-500">ë°ì´í„°ë¥¼ í‘œì‹œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>'; } 
                    finally { loadingSpinner.classList.add('hidden'); }
                };
                reader.onerror = (error) => { console.error("FileReader error:", error); fileErrorDisplay.textContent = "íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."; loadingSpinner.classList.add('hidden'); };
                reader.readAsArrayBuffer(file);
            } catch (err) { console.error("Error processing file:", err); fileErrorDisplay.textContent = `ì˜¤ë¥˜: ${err.message}`; loadingSpinner.classList.add('hidden'); }
        }
        
        function displayDataTable(headers, previewData, qTextRowZeroBased) {
            dataTableContainer.innerHTML = ''; 
            if (!previewData || previewData.length === 0) { dataTableContainer.innerHTML = '<p class="p-6 text-center text-slate-500">í‘œì‹œí•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</p>'; return; }
            const table = document.createElement('table'); table.className = 'min-w-full divide-y divide-slate-200';
            const thead = document.createElement('thead'); thead.className = 'bg-slate-100'; const headerRowUI = document.createElement('tr');
            headers.forEach(hT => { const th = document.createElement('th'); th.scope = 'col'; th.className = 'px-4 py-2.5 text-left text-xs font-medium text-slate-500 uppercase tracking-wider'; th.textContent = hT; headerRowUI.appendChild(th); });
            thead.appendChild(headerRowUI); table.appendChild(thead);
            const tbody = document.createElement('tbody'); tbody.className = 'bg-white divide-y divide-slate-200';
            const displayLimit = Math.min(previewData.length, 50); 
            for (let i = 0; i < displayLimit; i++) {
                const rDA = previewData[i];
                if (i === 0 && qTextRowZeroBased !== 0 && headers.every((h, idx) => h === rDA[idx])) continue; 
                const tr = document.createElement('tr');
                if (qTextRowZeroBased !== -1 && i === qTextRowZeroBased) tr.classList.add('question-text-row');
                headers.forEach((h, cI) => { const td = document.createElement('td'); td.className = 'px-4 py-2.5 whitespace-nowrap text-sm text-slate-700'; td.textContent = rDA[cI] !== undefined ? String(rDA[cI]) : ''; tr.appendChild(td); });
                tbody.appendChild(tr);
            }
            table.appendChild(tbody); dataTableContainer.appendChild(table);
            if (rawExcelData.length > displayLimit) { const notice = document.createElement('p'); notice.className = 'text-xs text-slate-500 p-2 text-center'; notice.textContent = `ë°ì´í„°ê°€ ë„ˆë¬´ ë§ì•„ ìƒìœ„ ${displayLimit}ê°œ í–‰ë§Œ í‘œì‹œí•©ë‹ˆë‹¤. ì „ì²´ ë°ì´í„°ëŠ” ë¶„ì„ì— ì‚¬ìš©ë©ë‹ˆë‹¤.`; dataTableContainer.appendChild(notice); }
        }

        function populateQuestionSelectors(headers, fullTexts, qTypes) { 
            questionCheckboxesContainer.innerHTML = ''; 
            selectAllQuestionsCheckbox.checked = false; 
            if (!headers || headers.length === 0) { questionCheckboxesContainer.innerHTML = '<p class="text-sm text-slate-400">ë¬¸í•­ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>'; return; }
            
            headers.forEach((h, i) => {
                const d = document.createElement('div'); d.className = 'flex items-center';
                const cId = `cb-question-${h.replace(/[^a-zA-Z0-9]/g, "_")}-${i}`; 
                const cb = document.createElement('input'); cb.type = 'checkbox'; cb.id = cId; cb.value = h; cb.className = 'h-4 w-4 rounded border-gray-300 text-sky-600 focus:ring-sky-500 question-item-checkbox';
                
                const l = document.createElement('label'); 
                l.htmlFor = cId; 
                l.className = 'ml-2 block text-sm text-slate-700 cursor-pointer question-item-label'; 
                const qTextOriginal = fullTexts[h] || h;
                l.title = qTextOriginal; 

                let qTextForSummary = qTextOriginal; 

                l.innerHTML = ''; // ê¸°ì¡´ ë‚´ìš© ì´ˆê¸°í™”
                if (qTypes[h] === 'subjective') {
                    const marker = document.createElement('span'); marker.className = 'subjective-marker'; marker.textContent = '[ì£¼ê´€ì‹]'; l.appendChild(marker);
                }
                l.appendChild(document.createTextNode(`${h} `)); 
                
                const summarySpan = document.createElement('span');
                summarySpan.className = 'question-summary';
                const truncatedSummary = qTextForSummary.length > 30 ? qTextForSummary.substring(0, 27) + '...' : qTextForSummary;
                summarySpan.textContent = `(ì§ˆë¬¸: ${truncatedSummary})`;
                l.appendChild(summarySpan); 
                
                d.appendChild(cb); 
                d.appendChild(l); 
                questionCheckboxesContainer.appendChild(d);
            });

            document.querySelectorAll('.crossAnalysisGroupingQuestion').forEach(sE => { // êµì°¨ë¶„ì„ ê·¸ë£¹í•‘ ë¬¸í•­ ì…€ë ‰í„° ì—…ë°ì´íŠ¸
                sE.innerHTML = '<option value="">-- ë¬¸í•­ ì„ íƒ --</option>'; 
                headers.forEach(h => { 
                    if (questionTypes[h] !== 'subjective') { // ì£¼ê´€ì‹ ì œì™¸
                        const o = document.createElement('option'); 
                        o.value = h; 
                        const qTTS = fullTexts[h] || h; 
                        const tT = qTTS.length > 40 ? qTTS.substring(0, 37) + '...' : qTTS; 
                        o.textContent = `${h} (${tT})`; 
                        sE.appendChild(o); 
                    }
                });
            });
        }
        
        function getSelectedQuestions() { const s = []; questionCheckboxesContainer.querySelectorAll('.question-item-checkbox:checked').forEach(cb => s.push(cb.value)); return s; }

        function handleQuestionRowChange() {
             if (rawExcelData.length > 0) { 
                processRawExcelData(rawExcelData);
                displayDataTable(excelHeaders, rawExcelData.slice(0, 50), questionTextRowIndex); 
                populateQuestionSelectors(excelHeaders, questionFullTexts, questionTypes); 
                detectAndDisplayLikertOptions(); 
                // êµì°¨ ë¶„ì„ ì„¹ì…˜ì˜ ë¦¬ì»¤íŠ¸ ë¬¸í•­ ëª©ë¡ë„ ì—…ë°ì´íŠ¸
                document.querySelectorAll('.cross-analysis-section').forEach((section, index) => {
                    populateCrossAnalysisLikertQuestions(section, index);
                });
            }
        }

        function handleProceedToStep3() {
            userLikertChoices = {}; 
            likertDefinitionContainer.querySelectorAll('input[type="radio"]:checked').forEach(radio => {
                if (radio.name.startsWith('likert-group-choice-')) {
                    const scaleId = radio.name.replace('likert-group-choice-', '');
                    const applyRule = radio.value === 'yes';
                    for (const qHeader in detectedLikertQuestions) {
                        if (detectedLikertQuestions[qHeader] === scaleId) {
                            userLikertChoices[qHeader] = applyRule;
                            if(applyRule && questionTypes[qHeader] !== 'subjective') { questionTypes[qHeader] = 'likert'; } 
                            else if (!applyRule && questionTypes[qHeader] === 'likert') { questionTypes[qHeader] = 'objective';}
                        }
                    }
                }
            });
            likertDefinitionSection.classList.add('hidden');
            graphConfigSection.classList.remove('hidden');
            graphConfigSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // --- Likert Scale Functions ---
        function detectAndDisplayLikertOptions() {
            likertDefinitionContainer.innerHTML = ''; 
            detectedLikertQuestions = {}; 
            const groupedByScale = {}; 

            excelHeaders.forEach(qHeader => {
                if (questionTypes[qHeader] === 'subjective') return;

                const responsesInQuestion = new Set();
                excelDataForAnalysis.forEach(row => {
                    if (row[qHeader] !== undefined && row[qHeader] !== null && String(row[qHeader]).trim() !== "") {
                        responsesInQuestion.add(String(row[qHeader]).trim());
                    }
                });
                if (responsesInQuestion.size === 0 || responsesInQuestion.size > 10) return; 

                let bestMatchScaleId = null;
                let highestMatchScore = 0;

                for (const scaleId in LIKERT_SCALES) {
                    const scale = LIKERT_SCALES[scaleId];
                    let currentMatchScore = 0;
                    let positiveResponsesFound = 0;
                    let negativeResponsesFound = 0;
                    let intensifierUsedCount = 0; 

                    responsesInQuestion.forEach(response => {
                        let responseMatchScore = 0;
                        let foundDirectResponseMatch = false;

                        if (scale.responses.includes(response)) {
                            responseMatchScore += 2; 
                            foundDirectResponseMatch = true;
                            const scoreIndex = scale.responses.indexOf(response);
                            if (scale.scores[scoreIndex] > 3) positiveResponsesFound++;
                            else if (scale.scores[scoreIndex] < 3) negativeResponsesFound++;
                        }

                        if (!foundDirectResponseMatch) {
                            let tempIntensifierUsed = false;
                            for (const intensifier of scale.intensifiers) {
                                if (response.includes(intensifier)) {
                                    tempIntensifierUsed = true;
                                    for (const pk of scale.positive_keywords) {
                                        if (response.includes(pk) && (response.startsWith(intensifier) || response.endsWith(pk))) { 
                                            responseMatchScore += 1.5;
                                            positiveResponsesFound++;
                                            break; 
                                        }
                                    }
                                    if (responseMatchScore > 0 && tempIntensifierUsed) break; 

                                    for (const nk of scale.negative_keywords) {
                                        if (response.includes(nk) && (response.startsWith(intensifier) || response.endsWith(nk))) {
                                            responseMatchScore += 1.5;
                                            negativeResponsesFound++;
                                            break;
                                        }
                                    }
                                    if (responseMatchScore > 0 && tempIntensifierUsed) break; 
                                }
                            }
                            if(tempIntensifierUsed) intensifierUsedCount++;
                        }
                        currentMatchScore += responseMatchScore;
                    });
                    
                    if (positiveResponsesFound > 0 && negativeResponsesFound > 0) {
                        const matchRatio = responsesInQuestion.size > 0 ? currentMatchScore / (responsesInQuestion.size * 2) : 0; 
                        const responseCountSimilarity = scale.responses.length > 0 ? 1 - (Math.abs(responsesInQuestion.size - scale.responses.length) / scale.responses.length) : 0;
                        const intensifierBonus = (intensifierUsedCount / responsesInQuestion.size) * 0.2; 
                        const finalScore = matchRatio * 0.6 + responseCountSimilarity * 0.2 + intensifierBonus;

                        if (finalScore > highestMatchScore && finalScore > 0.4) { 
                            highestMatchScore = finalScore;
                            bestMatchScaleId = scaleId;
                        }
                    }
                }

                if (bestMatchScaleId) {
                    detectedLikertQuestions[qHeader] = bestMatchScaleId;
                    questionTypes[qHeader] = 'likert'; 
                    if (!groupedByScale[bestMatchScaleId]) groupedByScale[bestMatchScaleId] = [];
                    groupedByScale[bestMatchScaleId].push(qHeader);
                } else if (questionTypes[qHeader] !== 'subjective') {
                    questionTypes[qHeader] = 'objective'; 
                }
            });
            
            let foundLikertCandidate = false;
            for (const scaleId in groupedByScale) {
                foundLikertCandidate = true;
                addLikertGroupChoiceToUI(scaleId, groupedByScale[scaleId]);
            }

            if (foundLikertCandidate) {
                likertInfoText.textContent = "ë°ì´í„°ì—ì„œ ë‹¤ìŒê³¼ ê°™ì€ ë¦¬ì»¤íŠ¸ ì²™ë„ ìœ í˜•(ë“¤)ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤. ê° ìœ í˜•ì— ëŒ€í•´ ê·œì¹™ ì ìš© ì—¬ë¶€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.";
                likertDefinitionSection.classList.remove('hidden');
            } else {
                likertInfoText.textContent = "ë°ì´í„°ì—ì„œ ë¦¬ì»¤íŠ¸ ì²™ë„ë¡œ ë³´ì´ëŠ” ë¬¸í•­ì´ ê°ì§€ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì¼ë°˜ ë¶„ì„ì„ ì§„í–‰í•©ë‹ˆë‹¤.";
                 likertDefinitionSection.classList.add('hidden'); 
            }
             // êµì°¨ ë¶„ì„ ì„¹ì…˜ì˜ ë¦¬ì»¤íŠ¸ ë¬¸í•­ ëª©ë¡ë„ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.cross-analysis-section').forEach((section, index) => {
                populateCrossAnalysisLikertQuestions(section, index);
            });
        }

        function addLikertGroupChoiceToUI(scaleId, qHeaders) {
            const scale = LIKERT_SCALES[scaleId];
            const container = document.createElement('div');
            container.className = 'likert-group-confirmation'; 

            let questionListHTML = '<ul class="list-disc list-inside likert-group-questions">';
            qHeaders.forEach(qHeader => {
                const qText = questionFullTexts[qHeader] || qHeader;
                const truncatedQText = qText.length > 60 ? qText.substring(0, 57) + '...' : qText;
                questionListHTML += `<li>${qHeader} (${truncatedQText})</li>`;
            });
            questionListHTML += '</ul>';

            container.innerHTML = `
                <p class="text-sm font-medium text-slate-700 mb-1">ê°ì§€ëœ ìœ í˜•: ${scale.name}</p>
                <p class="text-xs text-slate-500 mb-1">ì•„ë˜ ë¬¸í•­ë“¤ì´ ì´ ìœ í˜•ì— í•´ë‹¹ë˜ëŠ” ê²ƒìœ¼ë¡œ ë³´ì…ë‹ˆë‹¤:</p>
                ${questionListHTML}
                <p class="text-xs text-slate-500 mt-2 mb-3">ì´ ìœ í˜•ì˜ ëª¨ë“  ë¬¸í•­ì— ë¦¬ì»¤íŠ¸ ì²™ë„ ê·œì¹™ì„ ì ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</p>
                <div class="flex items-center space-x-4">
                    <div class="flex items-center">
                        <input type="radio" id="likert-group-choice-${scaleId}-yes" name="likert-group-choice-${scaleId}" value="yes" class="radio-input text-sky-600 focus:ring-sky-500" checked>
                        <label for="likert-group-choice-${scaleId}-yes" class="radio-label">ì˜ˆ (ë¦¬ì»¤íŠ¸ ê·œì¹™ ì¼ê´„ ì ìš©)</label>
                    </div>
                    <div class="flex items-center">
                        <input type="radio" id="likert-group-choice-${scaleId}-no" name="likert-group-choice-${scaleId}" value="no" class="radio-input text-sky-600 focus:ring-sky-500">
                        <label for="likert-group-choice-${scaleId}-no" class="radio-label">ì•„ë‹ˆì˜¤ (ì¼ê´„ ë¯¸ì ìš©, ì¼ë°˜ ë¶„ì„)</label>
                    </div>
                </div>
            `;
            likertDefinitionContainer.appendChild(container);
        }

        function getLikertScaleConfig(qHeader) {
            if (userLikertChoices[qHeader] === true && detectedLikertQuestions[qHeader]) {
                 if (questionTypes[qHeader] === 'likert') {
                    return LIKERT_SCALES[detectedLikertQuestions[qHeader]];
                 }
            }
            return null;
        }

        function calculateAverageScore(questionHeader, likertScale) {
            if (!likertScale || !excelDataForAnalysis) return null;
            let totalScore = 0; let validResponseCount = 0;
            excelDataForAnalysis.forEach(row => {
                const response = String(row[questionHeader]).trim();
                const responseIndex = likertScale.responses.indexOf(response);
                if (responseIndex !== -1) {
                    totalScore += likertScale.scores[responseIndex];
                    validResponseCount++;
                }
            });
            return validResponseCount > 0 ? (totalScore / validResponseCount) : null;
        }

        function countAndSortResponses(questionHeader, likertScale) {
            const counts = {};
            let totalValidResponses = 0;
            let otherResponsesCounts = 0; 
            const noResponseCounts = {}; 

            // Initialize counts for all defined Likert responses to 0
            if (likertScale) {
                likertScale.responses.forEach(respKey => {
                    counts[respKey] = 0;
                });
            }


            excelDataForAnalysis.forEach(row => {
                const response = row[questionHeader];
                let responseStr = String(response).trim();
                
                if (response === null || typeof response === 'undefined' || responseStr === '') {
                    responseStr = NO_RESPONSE_TERMS[0]; 
                }

                if (!NO_RESPONSE_TERMS.includes(responseStr)) {
                    totalValidResponses++;
                }

                if (likertScale && !likertScale.responses.includes(responseStr) && !NO_RESPONSE_TERMS.includes(responseStr)) {
                    otherResponsesCounts += 1; 
                } else if (NO_RESPONSE_TERMS.includes(responseStr)) {
                    noResponseCounts[responseStr] = (noResponseCounts[responseStr] || 0) + 1;
                }
                 else {
                    counts[responseStr] = (counts[responseStr] || 0) + 1;
                }
            });
            
            const percentageBase = totalValidResponses > 0 ? totalValidResponses : excelDataForAnalysis.length;
            const results = { labels: [], dataValues: [], percentages: [], counts: [], totalValidResponses: totalValidResponses };
            
            if (likertScale) {
                likertScale.responses.forEach((respKey) => {
                    const count = counts[respKey] || 0; 
                    results.labels.push(respKey);
                    results.dataValues.push(count);
                    results.percentages.push(percentageBase > 0 ? (count / percentageBase) * 100 : 0);
                    results.counts.push(count);
                });

                if (otherResponsesCounts > 0) {
                    results.labels.push(OTHER_RESPONSE_LABEL);
                    results.dataValues.push(otherResponsesCounts);
                    results.percentages.push(percentageBase > 0 ? (otherResponsesCounts / percentageBase) * 100 : 0);
                    results.counts.push(otherResponsesCounts);
                }
                
                let totalNoResponseCount = 0;
                NO_RESPONSE_TERMS.forEach(term => {
                    if(noResponseCounts[term]) totalNoResponseCount += noResponseCounts[term];
                });
                if (totalNoResponseCount > 0 && !results.labels.includes(NO_RESPONSE_TERMS[0])) { 
                    results.labels.push(NO_RESPONSE_TERMS[0]); 
                    results.dataValues.push(totalNoResponseCount);
                    results.percentages.push(percentageBase > 0 ? (totalNoResponseCount / percentageBase) * 100 : 0);
                    results.counts.push(totalNoResponseCount);
                }

            } else { 
                let numericEntries = [];
                let textEntries = [];
                let noResponseEntriesData = {}; 
                let otherTextEntries = []; 

                Object.keys(counts).forEach(label => {
                    if (NO_RESPONSE_TERMS.includes(label)) {
                        noResponseEntriesData[label] = (noResponseEntriesData[label] || 0) + counts[label];
                    } else {
                        const match = label.match(/^(\d+)[ì ê°œê°€]?\s*(.*)/);
                        if (match) {
                            numericEntries.push({ label: label, count: counts[label], numericValue: parseInt(match[1], 10), textPart: match[2] });
                        } else {
                            otherTextEntries.push({ label: label, count: counts[label] });
                        }
                    }
                });

                numericEntries.sort((a, b) => a.numericValue - b.numericValue);
                otherTextEntries.sort((a, b) => a.label.localeCompare(b.label, 'ko-KR'));
                
                const sortedEntries = [...numericEntries, ...otherTextEntries]; 

                sortedEntries.forEach(entry => {
                    results.labels.push(entry.label);
                    results.dataValues.push(entry.count);
                    results.percentages.push(percentageBase > 0 ? (entry.count / percentageBase) * 100 : 0);
                    results.counts.push(entry.count);
                });
                
                let totalNoResponseCount = 0;
                NO_RESPONSE_TERMS.forEach(term => {
                    if(noResponseEntriesData[term]) totalNoResponseCount += noResponseEntriesData[term];
                });
                if (totalNoResponseCount > 0 && !results.labels.includes(NO_RESPONSE_TERMS[0])) {
                    results.labels.push(NO_RESPONSE_TERMS[0]);
                    results.dataValues.push(totalNoResponseCount);
                    results.percentages.push(percentageBase > 0 ? (totalNoResponseCount / percentageBase) * 100 : 0);
                    results.counts.push(totalNoResponseCount);
                }
            }
            return results;
        }
        
        function displayAverageScore(parentElement, averageScore, likertScale) { 
            if (averageScore === null || !likertScale) return;
            const scoreDisplayDiv = document.createElement('div'); scoreDisplayDiv.className = 'average-score-display';
            const textP = document.createElement('p'); textP.className = 'average-score-text';
            textP.textContent = `í‰ê·  ì ìˆ˜: ${averageScore.toFixed(2)} / ${likertScale.scores[0]}ì `; 
            scoreDisplayDiv.appendChild(textP);
            const barContainer = document.createElement('div'); barContainer.className = 'average-score-bar-container';
            const barFill = document.createElement('div'); barFill.className = 'average-score-bar-fill';
            const percentage = (averageScore / likertScale.scores[0]) * 100;
            barFill.style.width = `${Math.max(0, Math.min(100, percentage))}%`; 
            barFill.textContent = `${averageScore.toFixed(2)}`;
            barContainer.appendChild(barFill); scoreDisplayDiv.appendChild(barContainer); 
            
            if (parentElement.firstChild && parentElement.firstChild.nextSibling) {
                 parentElement.insertBefore(scoreDisplayDiv, parentElement.firstChild.nextSibling);
            } else {
                parentElement.appendChild(scoreDisplayDiv); 
            }
        }

        // --- PNG and ZIP Download Functions ---
        function dataURLtoBlob(dataurl) {
            const arr = dataurl.split(',');
            const mime = arr[0].match(/:(.*?);/)[1];
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while (n--) {
                u8arr[n] = bstr.charCodeAt(n);
            }
            return new Blob([u8arr], { type: mime });
        }

        async function downloadChartAsPng(chartInfo, filenameSuffix = '') {
            return new Promise((resolve, reject) => {
                 if (!chartInfo || !chartInfo.instance || !chartInfo.instance.canvas) {
                    console.error("Invalid chartInfo for PNG export:", chartInfo);
                    return reject(new Error("ìœ íš¨í•˜ì§€ ì•Šì€ ì°¨íŠ¸ ì •ë³´ì…ë‹ˆë‹¤. (instance ë˜ëŠ” canvas ëˆ„ë½)"));
                }
                const canvas = chartInfo.instance.canvas;
                const qHeader = chartInfo.questionHeader || 'chart';
                const chartTitle = chartInfo.customTitle || (chartInfo.type === 'cross' || chartInfo.type === 'matrix' ? qHeader : (questionFullTexts[qHeader] || qHeader));
                const filename = `${chartTitle.replace(/[\s\/\\?%*:|"<>]/g, '_')}${filenameSuffix}.png`;

                try {
                    const dataUrl = canvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.href = dataUrl;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    resolve();
                } catch (error) {
                    console.error("PNG ìƒì„± ë˜ëŠ” ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜:", error);
                    reject(new Error(`PNG ìƒì„± ë˜ëŠ” ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜: ${error.message || String(error)}`));
                }
            });
        }
        
        async function downloadAllChartsAsPngZip() {
            if (activeCharts.length === 0) {
                alert("ë‹¤ìš´ë¡œë“œí•  ì°¨íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.");
                return;
            }
            if (typeof JSZip === 'undefined') {
                alert("ZIP ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ê±°ë‚˜ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.");
                return;
            }

            const zip = new JSZip();
            loadingSpinner.classList.remove('hidden'); 

            try {
                for (let i = 0; i < activeCharts.length; i++) {
                    const chartInfo = activeCharts[i];
                    if (!chartInfo || !chartInfo.instance || !chartInfo.instance.canvas) {
                        console.warn("Skipping chart due to invalid info (PNG ZIP):", chartInfo);
                        continue;
                    }
                    const canvas = chartInfo.instance.canvas;
                    const qHeader = chartInfo.questionHeader || `chart-${i + 1}`;
                    const chartTitle = chartInfo.customTitle || (chartInfo.type === 'cross' || chartInfo.type === 'matrix' ? qHeader : (questionFullTexts[qHeader] || qHeader));
                    const filenameBase = chartTitle.replace(/[\s\/\\?%*:|"<>]/g, '_');
                    
                    try {
                        const dataUrl = canvas.toDataURL('image/png');
                        const blob = dataURLtoBlob(dataUrl);
                        zip.file(`${filenameBase}.png`, blob);
                    } catch (error) {
                        console.error(`'${chartTitle}' PNG ìƒì„± ì‹¤íŒ¨:`, error.message || error);
                    }
                }

                if (Object.keys(zip.files).length > 0) {
                    zip.generateAsync({ type: "blob" })
                        .then(function(content) {
                            const link = document.createElement('a');
                            link.href = URL.createObjectURL(content);
                            link.download = "ë¬¸í•­ë¶„ì„_ì°¨íŠ¸ëª¨ìŒ_PNG.zip";
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            URL.revokeObjectURL(link.href);
                        })
                        .catch(err => {
                            console.error("ZIP ìƒì„± ì˜¤ë¥˜:", err);
                            alert(`ZIP íŒŒì¼ ìƒì„± ì¤‘ ì˜¤ë¥˜: ${err.message || String(err)}`);
                        })
                        .finally(() => {
                            loadingSpinner.classList.add('hidden');
                        });
                } else {
                    alert("PNGë¡œ ë³€í™˜í•  ìˆ˜ ìˆëŠ” ì°¨íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ì½˜ì†”ì—ì„œ ì˜¤ë¥˜ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.");
                    loadingSpinner.classList.add('hidden');
                }
            } catch (error) {
                console.error("ì „ì²´ PNG ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜:", error);
                alert(`ì „ì²´ PNG ë‹¤ìš´ë¡œë“œ ì¤‘ ì˜¤ë¥˜: ${error.message || String(error)}`);
                loadingSpinner.classList.add('hidden');
            }
        }

        function initializeColorPalettes() {
            // ë¦¬ì»¤íŠ¸ ì²™ë„ìš© íŒ”ë ˆíŠ¸ ì„ íƒê¸° ì´ˆê¸°í™”
            likertColorPaletteSelector.innerHTML = '';
            Object.keys(COLOR_PALETTES.likert).forEach((key) => {
                const palette = COLOR_PALETTES.likert[key];
                const radioId = `likert-palette-${key}`;
                
                const div = document.createElement('div');
                div.className = 'flex items-center';

                const input = document.createElement('input');
                input.type = 'radio';
                input.id = radioId;
                input.name = 'likertColorPaletteScheme';
                input.value = key;
                input.className = 'radio-input text-sky-600 focus:ring-sky-500';
                if (key === currentLikertPaletteKey) { 
                    input.checked = true;
                }
                input.addEventListener('change', (event) => {
                    currentLikertPaletteKey = event.target.value;
                });

                const label = document.createElement('label');
                label.htmlFor = radioId;
                label.className = 'radio-label flex items-center cursor-pointer';
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = PALETTE_NAMES.likert[key] || key;
                nameSpan.className = "mr-2";
                label.appendChild(nameSpan);

                const swatchesContainer = document.createElement('div');
                swatchesContainer.className = 'flex';
                palette.slice(0, 5).forEach(color => { 
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = color;
                    swatchesContainer.appendChild(swatch);
                });
                label.appendChild(swatchesContainer);
                
                div.appendChild(input);
                div.appendChild(label);
                likertColorPaletteSelector.appendChild(div);
            });

            // ì¼ë°˜ ì°¨íŠ¸ìš© íŒ”ë ˆíŠ¸ ì„ íƒê¸° ì´ˆê¸°í™”
            generalColorPaletteSelector.innerHTML = '';
            Object.keys(COLOR_PALETTES.general).forEach((key) => {
                const palette = COLOR_PALETTES.general[key];
                const radioId = `general-palette-${key}`;
                
                const div = document.createElement('div');
                div.className = 'flex items-center';

                const input = document.createElement('input');
                input.type = 'radio';
                input.id = radioId;
                input.name = 'generalColorPaletteScheme';
                input.value = key;
                input.className = 'radio-input text-sky-600 focus:ring-sky-500';
                if (key === currentGeneralPaletteKey) { 
                    input.checked = true;
                }
                input.addEventListener('change', (event) => {
                    currentGeneralPaletteKey = event.target.value;
                });

                const label = document.createElement('label');
                label.htmlFor = radioId;
                label.className = 'radio-label flex items-center cursor-pointer';
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = PALETTE_NAMES.general[key] || key;
                nameSpan.className = "mr-2";
                label.appendChild(nameSpan);

                const swatchesContainer = document.createElement('div');
                swatchesContainer.className = 'flex';
                palette.slice(0, 5).forEach(color => { 
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = color;
                    swatchesContainer.appendChild(swatch);
                });
                label.appendChild(swatchesContainer);
                
                div.appendChild(input);
                div.appendChild(label);
                generalColorPaletteSelector.appendChild(div);
            });
        }

        function handleChartTitleBlur(event) {
            const chartIndex = parseInt(event.target.dataset.chartIndex, 10);
            if (isNaN(chartIndex) || chartIndex < 0 || chartIndex >= activeCharts.length) return;
            
            const newTitle = event.target.textContent.trim();
            if (newTitle === "") { // ì œëª©ì´ ë¹„ì›Œì¡Œìœ¼ë©´ ì›ë˜ ì œëª©ìœ¼ë¡œ ë³µì›
                event.target.textContent = activeCharts[chartIndex].originalTitle;
                activeCharts[chartIndex].customTitle = activeCharts[chartIndex].originalTitle;
            } else {
                activeCharts[chartIndex].customTitle = newTitle;
            }
        }

        function handleChartTitleKeydown(event) {
            const chartIndex = parseInt(event.target.dataset.chartIndex, 10);
            if (isNaN(chartIndex) || chartIndex < 0 || chartIndex >= activeCharts.length) return;

            if (event.key === 'Enter') {
                event.preventDefault();
                event.target.blur();
            } else if (event.key === 'Escape') {
                event.target.textContent = activeCharts[chartIndex].originalTitle;
                activeCharts[chartIndex].customTitle = activeCharts[chartIndex].originalTitle; // Escape ì‹œ customTitleë„ ì›ë³µ
                event.target.blur();
            }
        }


        function generateChartsFromSelection() {
            activeCharts.forEach(chartInfo => { if (chartInfo.instance) chartInfo.instance.destroy(); });
            activeCharts = []; 
            chartsArea.innerHTML = ''; 
            const selectedQuestions = getSelectedQuestions(); 
            const chosenChartType = chartTypeSelect.value;
            const crossAnalysisConfigs = getCrossAnalysisConfigs(); 
            let chartsGenerated = false;

            const selectedLikertPaletteRadio = document.querySelector('input[name="likertColorPaletteScheme"]:checked');
            if (selectedLikertPaletteRadio) currentLikertPaletteKey = selectedLikertPaletteRadio.value;
            
            const selectedGeneralPaletteRadio = document.querySelector('input[name="generalColorPaletteScheme"]:checked');
            if (selectedGeneralPaletteRadio) currentGeneralPaletteKey = selectedGeneralPaletteRadio.value;


            if (selectedQuestions.length > 0) {
                chartsGenerated = true;
                selectedQuestions.forEach((qHeader, index) => {
                    const vizWrapper = document.createElement('div'); vizWrapper.className = 'viz-wrapper';
                    const chartArrayIndex = activeCharts.length; 
                    
                    const originalChartTitle = questionFullTexts[qHeader] || qHeader; 
                    const titleElement = document.createElement('h4'); 
                    titleElement.className = 'text-md font-semibold text-center mb-3 text-slate-700 break-words';
                    titleElement.textContent = originalChartTitle; 
                    titleElement.contentEditable = true;
                    titleElement.dataset.chartIndex = chartArrayIndex; 
                    titleElement.addEventListener('blur', handleChartTitleBlur);
                    titleElement.addEventListener('keydown', handleChartTitleKeydown);
                    vizWrapper.appendChild(titleElement);
                    
                    const qType = questionTypes[qHeader]; 
                    const likertScaleConfig = getLikertScaleConfig(qHeader); 
                    const chartData = countAndSortResponses(qHeader, likertScaleConfig); 

                    if (likertScaleConfig) { 
                        const avgS = calculateAverageScore(qHeader, likertScaleConfig); 
                        if (avgS !== null) displayAverageScore(vizWrapper, avgS, likertScaleConfig); 
                    }
                    
                    const totalResponsesDiv = document.createElement('div');
                    totalResponsesDiv.className = 'total-responses-text';
                    totalResponsesDiv.textContent = `ì´ ì‘ë‹µ: ${formatNumberWithCommas(chartData.totalValidResponses)}ê°œ`;
                    if (vizWrapper.querySelector('.average-score-display')) { vizWrapper.insertBefore(totalResponsesDiv, vizWrapper.querySelector('.average-score-display').nextSibling); } 
                    else { vizWrapper.insertBefore(totalResponsesDiv, vizWrapper.firstChild.nextSibling); }

                    const chartActionsContainer = document.createElement('div'); 
                    chartActionsContainer.className = 'chart-actions-container';

                    if (qType === 'subjective') {
                        const responseContainer = document.createElement('div'); responseContainer.className = 'subjective-responses-container';
                        const uniqueResponses = new Set();
                         excelDataForAnalysis.forEach(row => { const resp = String(row[qHeader] || '').trim(); if (resp) uniqueResponses.add(resp); });
                         if (uniqueResponses.size > 0) { uniqueResponses.forEach(resp => { const p = document.createElement('p'); p.textContent = resp; responseContainer.appendChild(p); });
                        } else { responseContainer.innerHTML = `<p class="text-center text-slate-500 p-4">ì‘ë‹µ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.</p>`; }
                        vizWrapper.appendChild(responseContainer);
                    } else {
                        const chartContainer = document.createElement('div'); chartContainer.className = 'chart-canvas-container';
                        const canvas = document.createElement('canvas'); canvas.id = `chart-${qHeader.replace(/[^a-zA-Z0-9]/g, "_")}-${chartArrayIndex}`; 
                        chartContainer.appendChild(canvas); vizWrapper.appendChild(chartContainer); 

                        if (chartData.labels.length === 0 && !likertScaleConfig) { 
                            chartContainer.innerHTML = `<p class="text-center text-slate-500 p-4">"${qHeader}" ë¬¸í•­ì— ëŒ€í•œ ì‘ë‹µ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</p>`; 
                            chartsArea.appendChild(vizWrapper); return; 
                        }
                        
                        const chartInfo = {
                            originalCanvas: canvas,
                            questionHeader: qHeader,
                            type: 'basic',
                            chartData: chartData, 
                            qType: qType,
                            likertScaleConfig: likertScaleConfig,
                            currentChartType: chosenChartType,
                            originalTitle: originalChartTitle, 
                            customTitle: originalChartTitle,
                            customLabels: {} 
                        };
                        activeCharts.push(chartInfo);
                        renderIndividualChart(chartArrayIndex, chosenChartType); 

                        // Add individual chart type selector
                        const individualChartTypeSelect = document.createElement('select');
                        individualChartTypeSelect.className = 'individual-chart-type-select ml-2';
                        const types = [
                            {value: 'bar', text: 'ğŸ“Š ì„¸ë¡œ ë¹„ìœ¨'}, {value: 'horizontalBar', text: 'ğŸ“Š ê°€ë¡œ ë¹„ìœ¨'},
                            {value: 'stackedBar', text: 'ğŸ“¶ ì„¸ë¡œ ì „ì²´ ëˆ„ì '}, {value: 'stackedHorizontalBar', text: 'â†”ï¸ ê°€ë¡œ ì „ì²´ ëˆ„ì '},
                            {value: 'pie', text: 'ğŸ¥§ ì›í˜•'}, {value: 'doughnut', text: 'ğŸ© ë„ë„›í˜•'}
                        ];
                        types.forEach(opt => {
                            const option = document.createElement('option');
                            option.value = opt.value;
                            option.textContent = opt.text;
                            if (opt.value === chosenChartType) option.selected = true;
                            individualChartTypeSelect.appendChild(option);
                        });
                        individualChartTypeSelect.addEventListener('change', (e) => {
                            updateIndividualChartType(chartArrayIndex, e.target.value); 
                        });
                        chartActionsContainer.appendChild(individualChartTypeSelect);

                        // Add "ë ˆì´ë¸” í¸ì§‘" button
                        const editLabelsButton = document.createElement('button');
                        editLabelsButton.textContent = 'ë ˆì´ë¸” í¸ì§‘';
                        editLabelsButton.className = 'download-button download-csv-button ml-2'; // Reusing some styles
                        editLabelsButton.onclick = () => openLabelEditModal(chartArrayIndex);
                        chartActionsContainer.appendChild(editLabelsButton);
                    }
                    vizWrapper.appendChild(chartActionsContainer); 
                    chartsArea.appendChild(vizWrapper); 
                });
            }

            if (crossAnalysisConfigs.length > 0) {
                chartsGenerated = true;
                crossAnalysisConfigs.forEach((crossConfig, crossIndex) => {
                    if (crossConfig.likertQuestions && crossConfig.likertQuestions.length > 0 && crossConfig.groupingQuestion) {
                        generateCrossAnalysisChart(crossConfig, `matrix-${crossIndex}`);
                    }
                });
            }

            if (!chartsGenerated) {
                noDataMessage.classList.remove('hidden');
                chartsAreaContainer.classList.add('hidden');
                downloadAllPngBtn.classList.add('hidden');
            } else {
                chartDisplaySection.classList.remove('hidden'); 
                downloadAllPngBtn.classList.remove('hidden');
                chartDisplaySection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }
        
        function updateIndividualChartType(chartIndex, newChartType) {
            const chartInfo = activeCharts[chartIndex];
            if (!chartInfo || !chartInfo.originalCanvas) return;

            if (chartInfo.instance) {
                chartInfo.instance.destroy();
            }
            chartInfo.currentChartType = newChartType; 
            
            if (chartInfo.type === 'basic') {
                renderIndividualChart(chartIndex, newChartType);
            } else if (chartInfo.type === 'matrix') {
                const config = {
                    likertQuestions: chartInfo.likertQuestions,
                    groupingQuestion: chartInfo.groupingQuestion,
                    crossChartType: newChartType, 
                    idSuffix: chartInfo.originalCanvas.id.split('-').pop() 
                };
                const vizWrapper = chartInfo.originalCanvas.closest('.viz-wrapper');
                const chartContainer = vizWrapper.querySelector('.chart-canvas-container');
                chartContainer.innerHTML = ''; 
                const newCanvas = document.createElement('canvas');
                newCanvas.id = chartInfo.originalCanvas.id; 
                chartContainer.appendChild(newCanvas);
                chartInfo.originalCanvas = newCanvas; 

                generateCrossAnalysisChart(config, config.idSuffix, true, chartIndex); 
            }
        }

        function renderIndividualChart(chartIndex, chartTypeToRender) {
            const chartInfo = activeCharts[chartIndex];
            if (!chartInfo) return; 
            const { originalCanvas, questionHeader, chartData, qType, likertScaleConfig, customLabels } = chartInfo;
            
            if (!chartData) {
                console.error("Chart data is missing for chartIndex:", chartIndex);
                if (originalCanvas && originalCanvas.parentElement) {
                     originalCanvas.parentElement.innerHTML = `<p class="text-center text-red-500 p-4">ì°¨íŠ¸ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>`;
                }
                return;
            }

            const originalLabels = chartData.labels;
            const displayLabels = originalLabels.map(label => (customLabels && customLabels[label]) ? customLabels[label] : label);
            
            const orderedPercentages = [];
            const orderedCounts = [];
            
            originalLabels.forEach(originalLabel => { 
                const dataIndex = chartData.labels.indexOf(originalLabel);
                if (dataIndex !== -1) {
                    orderedPercentages.push(chartData.percentages[dataIndex]);
                    orderedCounts.push(chartData.counts[dataIndex]);
                }
            });


            let finalChartBackgroundColor = [];
            let activePaletteForCurrentChart;

            if (qType === 'likert' && likertScaleConfig) {
                activePaletteForCurrentChart = COLOR_PALETTES.likert[currentLikertPaletteKey];
                displayLabels.forEach((label, i) => { 
                    const originalLabelForColor = originalLabels[i]; 
                    if (label === OTHER_RESPONSE_LABEL ) { finalChartBackgroundColor.push(OTHER_RESPONSE_COLOR); } 
                    else if (NO_RESPONSE_TERMS.includes(label)) { finalChartBackgroundColor.push(NO_RESPONSE_COLOR); } 
                    else if (currentLikertPaletteKey === 'default' && likertScaleConfig.colors && likertScaleConfig.responses.includes(originalLabelForColor)) {
                        finalChartBackgroundColor.push(likertScaleConfig.colors[likertScaleConfig.responses.indexOf(originalLabelForColor)]);
                    } else {
                        const actualResponseLabels = displayLabels.filter(l => l !== OTHER_RESPONSE_LABEL && !NO_RESPONSE_TERMS.includes(l));
                        const actualIndex = actualResponseLabels.indexOf(label);
                        if (actualIndex !== -1 && activePaletteForCurrentChart) {
                            finalChartBackgroundColor.push(activePaletteForCurrentChart[actualIndex % activePaletteForCurrentChart.length]);
                        } else if (activePaletteForCurrentChart) { 
                            finalChartBackgroundColor.push(activePaletteForCurrentChart[i % activePaletteForCurrentChart.length]);
                        } else { 
                            finalChartBackgroundColor.push(COLOR_PALETTES.general.default[i % COLOR_PALETTES.general.default.length]);
                        }
                    }
                });
            } else { 
                activePaletteForCurrentChart = COLOR_PALETTES.general[currentGeneralPaletteKey];
                displayLabels.forEach((label, i) => { 
                    finalChartBackgroundColor.push(activePaletteForCurrentChart[i % activePaletteForCurrentChart.length]);
                });
            }

            let datasets = [];
            let chartLabelsForRender = displayLabels; 
            let chartTypeForConfig = 'bar';
            if (chartTypeToRender === 'pie' || chartTypeToRender === 'doughnut') { chartTypeForConfig = chartTypeToRender; }
            let isStacked = chartTypeToRender === 'stackedBar' || chartTypeToRender === 'stackedHorizontalBar';
            let currentChartIndexAxis = (chartTypeToRender === 'horizontalBar' || chartTypeToRender === 'stackedHorizontalBar') ? 'y' : 'x';

            if (isStacked) {
                chartLabelsForRender = [chartInfo.customTitle || questionHeader]; 
                displayLabels.forEach((label, i) => { 
                    datasets.push({ 
                        label: label, 
                        data: [orderedPercentages[i]], 
                        backgroundColor: finalChartBackgroundColor[i] || (qType === 'likert' ? COLOR_PALETTES.likert[currentLikertPaletteKey] : COLOR_PALETTES.general[currentGeneralPaletteKey])[i % (qType === 'likert' ? COLOR_PALETTES.likert[currentLikertPaletteKey] : COLOR_PALETTES.general[currentGeneralPaletteKey]).length], 
                        counts: [orderedCounts[i]],
                        barPercentage: 0.6, 
                        categoryPercentage: 0.7 
                    }); 
                });
            } else if (chartTypeToRender === 'bar' || chartTypeToRender === 'horizontalBar') {
                 datasets.push({ label: `${chartInfo.customTitle || questionHeader} ì‘ë‹µ ë¶„í¬ (%)`, data: orderedPercentages, backgroundColor: finalChartBackgroundColor, counts: orderedCounts });
            } else { 
                 datasets.push({ label: `${chartInfo.customTitle || questionHeader} ì‘ë‹µ ë¶„í¬`, data: orderedCounts, backgroundColor: finalChartBackgroundColor, hoverOffset: 4, percentages: orderedPercentages, counts: orderedCounts });
            }

            const datalabelsConfig = {
                display: true, 
                formatter: (value, context) => {
                    let displayValue = 0;
                    let countForLabel = 0;
                    if (chartTypeToRender === 'pie' || chartTypeToRender === 'doughnut') {
                        countForLabel = context.dataset.counts[context.dataIndex];
                        const totalCount = context.dataset.counts.reduce((a, b) => a + b, 0);
                        displayValue = totalCount > 0 ? (countForLabel / totalCount) * 100 : 0;
                    } else { 
                        displayValue = value; 
                        countForLabel = context.dataset.counts[context.dataIndex];
                    }
                     return displayValue > 0 ? displayValue.toFixed(1) + '%' : (displayValue === 0 ? '0.0%' : ''); // 0ì¼ë•Œë„ 0.0% í‘œì‹œ
                },
                color: (context) => {
                    if (chartTypeToRender === 'bar' || chartTypeToRender === 'horizontalBar') { return '#000000'; }
                    const bgColor = Array.isArray(context.dataset.backgroundColor) ? context.dataset.backgroundColor[context.dataIndex] : context.dataset.backgroundColor;
                    if (!bgColor) return '#000'; return isColorLight(bgColor) ? '#000' : '#fff';
                },
                font: { size: 10, weight: '600' }
            };
             if (isStacked) { datalabelsConfig.anchor = 'center'; datalabelsConfig.align = 'center'; datalabelsConfig.offset = 0; } 
            else if (chartTypeToRender === 'horizontalBar') { datalabelsConfig.anchor = 'end'; datalabelsConfig.align = 'right'; datalabelsConfig.offset = 4; } 
            else if (chartTypeToRender === 'bar') { datalabelsConfig.anchor = 'end'; datalabelsConfig.align = 'top'; datalabelsConfig.offset = -4; } 
            else { datalabelsConfig.anchor = 'center'; datalabelsConfig.align = 'center'; datalabelsConfig.offset = 0; }


            const chartConfig = {
                type: chartTypeForConfig, data: { labels: chartLabelsForRender, datasets: datasets },
                options: { 
                    responsive: true, maintainAspectRatio: false, indexAxis: currentChartIndexAxis, scales: {}, 
                    plugins: { 
                        legend: { 
                            display: isStacked || chartTypeToRender === 'pie' || chartTypeToRender === 'doughnut' || chartTypeToRender === 'stackedHorizontalBar' || chartTypeToRender === 'stackedBar' || chartLabelsForRender.length > 7, 
                            labels: {
                                boxWidth: (chartTypeToRender === 'pie' || chartTypeToRender === 'doughnut' || chartTypeToRender === 'stackedHorizontalBar' || chartTypeToRender === 'stackedBar') ? 12 : 40, 
                                padding: (chartTypeToRender === 'pie' || chartTypeToRender === 'doughnut' || chartTypeToRender === 'stackedHorizontalBar' || chartTypeToRender === 'stackedBar') ? 10 : 20,
                                font: { size: 10 },
                                formatter: function(value, legendItem) {
                                    return truncateText(value, 15); 
                                }
                            }
                        },
                        tooltip: { callbacks: { label: function(context) {
                            let label = context.dataset.label || context.label || ''; let countValue; let percentageValue;
                            if (isStacked) { label = context.dataset.label; countValue = context.dataset.counts[context.dataIndex]; percentageValue = context.raw; } 
                            else if (chartTypeToRender === 'pie' || chartTypeToRender === 'doughnut') { countValue = context.dataset.counts[context.dataIndex]; percentageValue = context.dataset.percentages[context.dataIndex]; } 
                            else { countValue = context.dataset.counts[context.dataIndex]; percentageValue = context.raw; }
                            return `${label}: ${countValue} (${percentageValue.toFixed(1)}%)`;
                        }}},
                        datalabels: datalabelsConfig
                    } 
                } 
            };
            if (chartTypeToRender !== 'pie' && chartTypeToRender !== 'doughnut') {
                const isPercentageValueAxis = chartTypeToRender === 'bar' || chartTypeToRender === 'horizontalBar' || isStacked;
                chartConfig.options.scales = {
                    y: { 
                        beginAtZero: true, 
                        stacked: isStacked, 
                        max: (currentChartIndexAxis === 'x' && isPercentageValueAxis) ? 100 : undefined, 
                        ticks: { 
                            autoSkip: true,
                            maxRotation: 45,
                            minRotation: 0,
                            callback: (currentChartIndexAxis === 'x' && isPercentageValueAxis) ? value => value + '%' : 
                                function(value) { return truncateText(this.getLabelForValue(value), 12); } 
                        }, 
                        title: { display: (currentChartIndexAxis === 'x' && isPercentageValueAxis), text: 'ë°±ë¶„ìœ¨ (%)' }
                    }, 
                    x: { 
                        beginAtZero: true, 
                        stacked: isStacked, 
                        max: (currentChartIndexAxis === 'y' && isPercentageValueAxis) ? 100 : undefined, 
                        ticks: { 
                            autoSkip: true,
                            maxRotation: 45,
                            minRotation: 0,
                            callback: (currentChartIndexAxis === 'y' && isPercentageValueAxis) ? value => value + '%' : 
                                function(value) { return truncateText(this.getLabelForValue(value), 12); } 
                        }, 
                        title: { display: (currentChartIndexAxis === 'y' && isPercentageValueAxis), text: 'ë°±ë¶„ìœ¨ (%)' }
                    }  
                };
                if (!isStacked) { 
                    if (currentChartIndexAxis === 'y') { delete chartConfig.options.scales.y.title; delete chartConfig.options.scales.y.max; } 
                    else { delete chartConfig.options.scales.x.title; delete chartConfig.options.scales.x.max; }
                }
            } else { delete chartConfig.options.scales; }
            
            try { 
                chartInfo.instance = new Chart(originalCanvas, chartConfig); 
            } catch (error) { console.error("Error re-rendering chart:", error, "for question:", questionHeader, chartConfig); originalCanvas.parentElement.innerHTML = `<p class="text-center text-red-500 p-4">ì°¨íŠ¸ë¥¼ ë‹¤ì‹œ ê·¸ë¦¬ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</p>`; }
        }


        function getCrossAnalysisConfigs() {
            const configs = [];
            const sections = document.querySelectorAll('.cross-analysis-section');
            sections.forEach((section, index) => {
                const settingsDiv = section.querySelector('.cross-analysis-settings');
                if (settingsDiv && !settingsDiv.classList.contains('hidden')) { 
                    const selectedLikertCheckboxes = section.querySelectorAll('.cross-analysis-likert-item-checkbox:checked');
                    const likertQuestions = [];
                    selectedLikertCheckboxes.forEach(cb => likertQuestions.push(cb.value));
                    
                    const groupingSelect = section.querySelector('.crossAnalysisGroupingQuestion');
                    const chartTypeSelect = section.querySelector('.crossAnalysisChartType'); 
                    
                    if (likertQuestions.length > 0 && groupingSelect && groupingSelect.value && chartTypeSelect && chartTypeSelect.value) { 
                        configs.push({
                            likertQuestions: likertQuestions,
                            groupingQuestion: groupingSelect.value,
                            crossChartType: chartTypeSelect.value, 
                            idSuffix: index 
                        });
                    }
                }
            });
            return configs;
        }
        
        // ê³µí†µ ì ‘ë‘ì‚¬ ì°¾ê¸° í•¨ìˆ˜ (í–‰ë ¬í˜• ì°¨íŠ¸ ë ˆì´ë¸”ìš©)
        function findCommonPrefixForMatrixLabels(strings) {
            if (!strings || strings.length === 0) return ""; 
            if (strings.length === 1) return ""; 

            let prefix = strings[0];
            for (let i = 1; i < strings.length; i++) {
                if (!strings[i]) return ""; 
                while (strings[i].indexOf(prefix) !== 0) {
                    prefix = prefix.substring(0, prefix.length - 1);
                    if (prefix === "") return "";
                }
            }
            
            const remainders = strings.map(s => s.substring(prefix.length).trimStart());
            if (remainders.some(r => r.length < 2) && strings.length > 1) { 
                 return ""; 
            }
            if (remainders.length > 1 && new Set(remainders).size === 1 && remainders[0] === "") { 
                return ""; 
            }
            
            const delimiters = [" - ", ": ", ". ", ") ", "] ", "_", "ì§ˆë¬¸", "ë¬¸í•­"]; 
            let bestDelimiterIndex = -1;
            let bestDelimiter = "";

            delimiters.forEach(d => {
                let tempPrefix = prefix;
                let lastIndexOfDelimiter = tempPrefix.lastIndexOf(d);
                if (lastIndexOfDelimiter !== -1 && lastIndexOfDelimiter + d.length <= tempPrefix.length) {
                     const potentialPrefixEnd = lastIndexOfDelimiter + d.length;
                     if (potentialPrefixEnd > bestDelimiterIndex) {
                        bestDelimiterIndex = potentialPrefixEnd;
                        bestDelimiter = tempPrefix.substring(0, bestDelimiterIndex);
                    }
                }
            });
            
            if (bestDelimiter) {
                prefix = bestDelimiter;
            } else {
                const lastSpace = prefix.trimEnd().lastIndexOf(" ");
                if (lastSpace > 0 && prefix.substring(0, lastSpace + 1).length >=3 ) {
                    prefix = prefix.substring(0, lastSpace + 1);
                } else if (prefix.length < 3 && !/Q\d*\W/.test(prefix) && !/ë¬¸í•­\d*\W/.test(prefix) ) { 
                    return "";
                }
            }
            return prefix.trim();
        }


        function generateCrossAnalysisChart(config, idSuffix, isReRender = false, chartIndexToUpdate = -1) { 
            const { likertQuestions, groupingQuestion, crossChartType } = config; 
            
            let vizWrapper;
            let currentChartArrayIndex = chartIndexToUpdate;

            if (isReRender && chartIndexToUpdate !== -1) {
                const existingCanvas = document.getElementById(`matrix-chart-${idSuffix}`);
                 if (existingCanvas) {
                    vizWrapper = existingCanvas.closest('.viz-wrapper');
                } else { 
                    console.error(`Cannot find vizWrapper for re-render: matrix-chart-${idSuffix}`);
                    return;
                }
            } else {
                vizWrapper = document.createElement('div');
                vizWrapper.className = 'viz-wrapper full-width-xl'; 
                chartsArea.appendChild(vizWrapper);
                currentChartArrayIndex = activeCharts.length; // For new chart
            }

            const originalTitleText = `${questionFullTexts[groupingQuestion] || groupingQuestion} ë³„ ë¦¬ì»¤íŠ¸ ë¬¸í•­ ${crossChartType === 'averageScoreBar' ? 'í‰ê·  ë¹„êµ' : (crossChartType === 'stackedPercentageBar' ? 'ì‘ë‹µ ë¹„ìœ¨ ë¹„êµ' : 'ì „ì²´ í‰ê·  ë¹„êµ')}`;
            let titleElement = vizWrapper.querySelector('h4');
            if (!titleElement) {
                titleElement = document.createElement('h4');
                titleElement.className = 'text-md font-semibold text-center mb-3 text-slate-700 break-words';
                vizWrapper.insertBefore(titleElement, vizWrapper.firstChild); 
            }
            
            titleElement.textContent = (isReRender && currentChartArrayIndex !== -1 && activeCharts[currentChartArrayIndex] && activeCharts[currentChartArrayIndex].customTitle) ? activeCharts[currentChartArrayIndex].customTitle : originalTitleText; 
            titleElement.contentEditable = true;
            titleElement.dataset.chartIndex = currentChartArrayIndex; 
            
            titleElement.removeEventListener('blur', handleChartTitleBlur); 
            titleElement.removeEventListener('keydown', handleChartTitleKeydown);
            titleElement.addEventListener('blur', handleChartTitleBlur);
            titleElement.addEventListener('keydown', handleChartTitleKeydown);


            let chartContainer = vizWrapper.querySelector('.chart-canvas-container');
            if (!chartContainer) {
                chartContainer = document.createElement('div');
                chartContainer.className = 'chart-canvas-container';
                vizWrapper.appendChild(chartContainer);
            }
            chartContainer.innerHTML = ''; 
            const canvas = document.createElement('canvas');
            canvas.id = `matrix-chart-${idSuffix}`;
            chartContainer.appendChild(canvas);
            
            let chartActionsContainer = vizWrapper.querySelector('.chart-actions-container');
            if(!chartActionsContainer) {
                chartActionsContainer = document.createElement('div'); 
                chartActionsContainer.className = 'chart-actions-container';
                vizWrapper.appendChild(chartActionsContainer);
            } else {
                chartActionsContainer.innerHTML = ''; 
            }


            const matrixData = processCrossAnalysisDataMatrix(likertQuestions, groupingQuestion, crossChartType);

            if (!matrixData || matrixData.labels.length === 0 || matrixData.datasets.length === 0) {
                chartContainer.innerHTML = `<p class="text-center text-slate-500 p-4">êµì°¨ ë¶„ì„ ë°ì´í„°ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ì„ íƒëœ ë¦¬ì»¤íŠ¸ ë¬¸í•­ ë˜ëŠ” ê·¸ë£¹í™” ê¸°ì¤€ ë¬¸í•­ì„ í™•ì¸í•´ì£¼ì„¸ìš”)</p>`;
                return;
            }
            
            const chartConfig = {
                type: 'bar', 
                data: {
                    labels: matrixData.labels, 
                    datasets: matrixData.datasets 
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: (crossChartType === 'stackedHorizontalPercentageBar' || crossChartType === 'overallHorizontalAverageScoreBar') ? 'y' : 'x', 
                    scales: {
                        y: { 
                            beginAtZero: true, 
                            stacked: crossChartType === 'stackedPercentageBar' || crossChartType === 'stackedHorizontalPercentageBar', 
                            max: crossChartType === 'stackedPercentageBar' || crossChartType === 'stackedHorizontalPercentageBar' ? 100 : (crossChartType === 'averageScoreBar' || crossChartType === 'overallAverageScoreBar' || crossChartType === 'overallHorizontalAverageScoreBar' ? 5 : undefined), 
                            title: { display: true, text: crossChartType === 'stackedPercentageBar' || crossChartType === 'stackedHorizontalPercentageBar' ? 'ë°±ë¶„ìœ¨ (%)' : 'í‰ê·  ì ìˆ˜'} 
                        },
                        x: {  
                            stacked: crossChartType === 'stackedPercentageBar' || crossChartType === 'stackedHorizontalPercentageBar', 
                            title: { display: true, text: 'ë¦¬ì»¤íŠ¸ ë¬¸í•­' },
                            ticks: {
                                autoSkip: false, 
                                maxRotation: 70, 
                                minRotation: 30,
                                callback: function(value) { 
                                    const label = this.getLabelForValue(value);
                                    return truncateText(label, 12); 
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { 
                            display: crossChartType !== 'overallAverageScoreBar' && crossChartType !== 'overallHorizontalAverageScoreBar', 
                             labels: {
                                font: {size: 10},
                                boxWidth: 12,
                                padding: 10,
                                formatter: function(value, legendItem) {
                                    return truncateText(value, 15); 
                                }
                            }
                        }, 
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) { label += ': '; }
                                    let value = context.parsed.y;
                                     if (crossChartType === 'averageScoreBar' || crossChartType === 'overallAverageScoreBar' || crossChartType === 'overallHorizontalAverageScoreBar') {
                                        label += value.toFixed(2) + 'ì ';
                                    } else { // stackedPercentageBar or stackedHorizontalPercentageBar
                                        label += value.toFixed(1) + '%';
                                    }
                                    return label;
                                }
                            }
                        },
                        datalabels: { 
                            display: crossChartType === 'averageScoreBar' || crossChartType === 'overallAverageScoreBar' || crossChartType === 'overallHorizontalAverageScoreBar', 
                            formatter: (value, context) => {
                                return value.toFixed(2);
                            },
                            font: { size: 9 },
                            anchor: 'end',
                            align: 'top',
                            offset: -2
                        }
                    }
                }
            };
            
            try {
                const newChart = new Chart(canvas, chartConfig);
                const chartInfoObject = { 
                    instance: newChart, 
                    questionHeader: `êµì°¨ë¶„ì„_${groupingQuestion}_vs_${likertQuestions.join('-')}_${crossChartType}`, 
                    type: 'matrix', 
                    originalCanvas: canvas,
                    chartData: matrixData, 
                    crossChartType: crossChartType, 
                    groupingQuestion: groupingQuestion, 
                    likertQuestions: likertQuestions,
                    originalTitle: originalTitleText,
                    customTitle: titleElement.textContent,
                    customLabels: (isReRender && currentChartArrayIndex !== -1 && activeCharts[currentChartArrayIndex]) ? activeCharts[currentChartArrayIndex].customLabels : {}
                };

                if (isReRender && currentChartArrayIndex !== -1) {
                    activeCharts[currentChartArrayIndex] = chartInfoObject;
                } else {
                    activeCharts.push(chartInfoObject);
                }


                // Add individual chart type selector for matrix charts
                const individualMatrixTypeSelect = document.createElement('select');
                individualMatrixTypeSelect.className = 'individual-chart-type-select ml-2';
                let matrixChartTypes = [
                    { value: 'averageScoreBar', text: 'í‰ê·  ì ìˆ˜ (ê·¸ë£¹ ë§‰ëŒ€)' },
                    { value: 'stackedPercentageBar', text: '100% ëˆ„ì  ë¹„ìœ¨ (ê·¸ë£¹í˜•)' },
                    { value: 'overallAverageScoreBar', text: 'ê°œë³„ ë¬¸í•­ ì „ì²´ í‰ê· ' }
                ];
                
                matrixChartTypes.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt.value;
                    option.textContent = opt.text;
                    if (opt.value === crossChartType) option.selected = true;
                    individualMatrixTypeSelect.appendChild(option);
                });
                individualMatrixTypeSelect.addEventListener('change', (e) => {
                    const chartIndexToUpdate = activeCharts.findIndex(c => c.originalCanvas.id === canvas.id);
                    if (chartIndexToUpdate !== -1) {
                         const newCrossType = e.target.value;
                         activeCharts[chartIndexToUpdate].crossChartType = newCrossType;
                         if (activeCharts[chartIndexToUpdate].instance) {
                             activeCharts[chartIndexToUpdate].instance.destroy();
                         }
                         generateCrossAnalysisChart({
                             likertQuestions: activeCharts[chartIndexToUpdate].likertQuestions,
                             groupingQuestion: activeCharts[chartIndexToUpdate].groupingQuestion,
                             crossChartType: newCrossType,
                             idSuffix: idSuffix
                         }, true, chartIndexToUpdate); 
                    }
                });
                chartActionsContainer.appendChild(individualMatrixTypeSelect);


                const downloadPngBtn = document.createElement('button');
                downloadPngBtn.textContent = 'PNG ë‹¤ìš´ë¡œë“œ';
                downloadPngBtn.className = 'download-button download-png-button';
                downloadPngBtn.onclick = async () => {
                    try {
                        loadingSpinner.classList.remove('hidden');
                        await downloadChartAsPng(activeCharts.find(c => c.originalCanvas.id === canvas.id));
                    } catch (err) {
                        console.error("í–‰ë ¬í˜• êµì°¨ë¶„ì„ PNG ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜ ìƒì„¸:", err);
                        alert(`PNG íŒŒì¼ ìƒì„± ì¤‘ ì˜¤ë¥˜: ${err.message || "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."} ì½˜ì†”ì„ í™•ì¸í•´ì£¼ì„¸ìš”.`);
                    } finally {
                        loadingSpinner.classList.add('hidden');
                    }
                };
                chartActionsContainer.appendChild(downloadPngBtn);

                 // Add "ë ˆì´ë¸” í¸ì§‘" button for matrix charts
                const editMatrixLabelsButton = document.createElement('button');
                editMatrixLabelsButton.textContent = 'ë ˆì´ë¸” í¸ì§‘';
                editMatrixLabelsButton.className = 'download-button download-csv-button ml-2';
                editMatrixLabelsButton.onclick = () => openLabelEditModal(currentChartArrayIndex); // Use currentChartArrayIndex
                chartActionsContainer.appendChild(editMatrixLabelsButton);


            } catch (error) {
                console.error("Error creating matrix cross-analysis chart:", error, config, chartConfig);
                chartContainer.innerHTML = `<p class="text-center text-red-500 p-4">êµì°¨ ë¶„ì„ ì°¨íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</p>`;
            }
        }


        function processCrossAnalysisDataMatrix(selectedLikertHeaders, groupingQuestionHeader, crossChartType) {
            const groupingCategories = [...new Set(excelDataForAnalysis.map(row => String(row[groupingQuestionHeader]).trim()))].filter(r => r && !NO_RESPONSE_TERMS.includes(r));
            const activeGeneralPalette = COLOR_PALETTES.general[currentGeneralPaletteKey];
            
            const likertQuestionFullNames = selectedLikertHeaders.map(h => questionFullTexts[h] || h);
            const commonPrefix = findCommonPrefixForMatrixLabels(likertQuestionFullNames);
            const matrixLabels = likertQuestionFullNames.map(name => commonPrefix && name.startsWith(commonPrefix) ? name.substring(commonPrefix.length).trimStart() : name);

            const datasets = [];

            if (crossChartType === 'averageScoreBar') {
                groupingCategories.forEach((groupCategory, index) => {
                    const dataForGroup = [];
                    selectedLikertHeaders.forEach(likertHeader => {
                        const likertScale = getLikertScaleConfig(likertHeader); 
                        if (likertScale) {
                            let sumOfScores = 0;
                            let countOfScores = 0;
                            excelDataForAnalysis.forEach(row => {
                                if (String(row[groupingQuestionHeader]).trim() === groupCategory) {
                                    const response = String(row[likertHeader]).trim();
                                    const scoreIndex = likertScale.responses.indexOf(response);
                                    if (scoreIndex !== -1) {
                                        sumOfScores += likertScale.scores[scoreIndex];
                                        countOfScores++;
                                    }
                                }
                            });
                            dataForGroup.push(countOfScores > 0 ? sumOfScores / countOfScores : 0);
                        } else {
                            dataForGroup.push(0); 
                        }
                    });
                    datasets.push({
                        label: groupCategory,
                        data: dataForGroup,
                        backgroundColor: activeGeneralPalette[index % activeGeneralPalette.length],
                    });
                });
            } else if (crossChartType === 'stackedPercentageBar') {
                const representativeLikertScale = getLikertScaleConfig(selectedLikertHeaders[0]);
                if (!representativeLikertScale) return { labels: [], datasets: [] };

                const likertResponseCategories = [...representativeLikertScale.responses, OTHER_RESPONSE_LABEL, NO_RESPONSE_TERMS[0]];
                
                groupingCategories.forEach((groupCategory, groupIndex) => {
                    const datasetForGroup = {
                        label: groupCategory,
                        data: [],
                        backgroundColor: activeGeneralPalette[groupIndex % activeGeneralPalette.length],
                        stack: groupCategory // ê° ê·¸ë£¹ì„ ë³„ë„ì˜ ìŠ¤íƒìœ¼ë¡œ
                    };
                    selectedLikertHeaders.forEach(likertHeader => {
                        let totalInGroupForLikert = 0;
                        const countsInGroupForLikert = {};

                        excelDataForAnalysis.forEach(row => {
                            if (String(row[groupingQuestionHeader]).trim() === groupCategory) {
                                 const actualResponse = String(row[likertHeader]).trim();
                                 if (!NO_RESPONSE_TERMS.includes(actualResponse)) {
                                    totalInGroupForLikert++;
                                 }
                                 if (representativeLikertScale.responses.includes(actualResponse)) {
                                    countsInGroupForLikert[actualResponse] = (countsInGroupForLikert[actualResponse] || 0) + 1;
                                 } else if (!NO_RESPONSE_TERMS.includes(actualResponse)) {
                                    countsInGroupForLikert[OTHER_RESPONSE_LABEL] = (countsInGroupForLikert[OTHER_RESPONSE_LABEL] || 0) + 1;
                                 } else {
                                     countsInGroupForLikert[NO_RESPONSE_TERMS[0]] = (countsInGroupForLikert[NO_RESPONSE_TERMS[0]] || 0) + 1;
                                 }
                            }
                        });
                        // ì´ ë¶€ë¶„ì€ ìˆ˜ì •ì´ í•„ìš”í•©ë‹ˆë‹¤. ê° ë¦¬ì»¤íŠ¸ ì‘ë‹µ ì¹´í…Œê³ ë¦¬ê°€ ë°ì´í„°ì…‹ì´ ë˜ì–´ì•¼ í•˜ê³ ,
                        // ê° ë°ì´í„°ì…‹ì˜ data ë°°ì—´ì€ selectedLikertHeadersì— ëŒ€í•œ í•´ë‹¹ ì‘ë‹µì˜ *ì´ ê·¸ë£¹(groupCategory)*ì—ì„œì˜ ë¹„ìœ¨ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
                        // í˜„ì¬ ë¡œì§ì€ ê·¸ë£¹ë³„ë¡œ í•˜ë‚˜ì˜ ë°ì´í„°ì…‹ì„ ë§Œë“¤ê³ , ê·¸ ì•ˆì— ëª¨ë“  ë¦¬ì»¤íŠ¸ ë¬¸í•­ì— ëŒ€í•œ (ì˜ëª»ëœ) ë¹„ìœ¨ì„ ë„£ê³  ìˆìŠµë‹ˆë‹¤.
                        // ì„ì‹œë¡œ 0ì„ í‘¸ì‹œí•©ë‹ˆë‹¤. ì‹¤ì œ êµ¬í˜„ ì‹œ ì´ ë¶€ë¶„ì„ ìˆ˜ì •í•´ì•¼ í•©ë‹ˆë‹¤.
                        datasetForGroup.data.push(0); // TODO: ì´ ë¡œì§ì€ ìˆ˜ì •ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
                    });
                    // datasets.push(datasetForGroup); // ì´ ë°ì´í„°ì…‹ êµ¬ì¡°ëŠ” 100% ëˆ„ì  ê·¸ë£¹ ë§‰ëŒ€ì— ì í•©í•˜ì§€ ì•ŠìŒ.
                });
                 // 100% ëˆ„ì  ë¹„ìœ¨ ë§‰ëŒ€ ë°ì´í„° êµ¬ì¡° ì¬êµ¬ì„± í•„ìš”
                if (datasets.length === 0 && groupingCategories.length > 0) { 
                    groupingCategories.forEach((groupCategory, index) => {
                        datasets.push({
                            label: groupCategory,
                            data: selectedLikertHeaders.map(() => 0), 
                            backgroundColor: activeGeneralPalette[index % activeGeneralPalette.length],
                            stack: groupCategory
                        });
                    });
                }


            } else if (crossChartType === 'overallAverageScoreBar') {
                const averageScores = [];
                selectedLikertHeaders.forEach(likertHeader => {
                    const likertScale = getLikertScaleConfig(likertHeader);
                    if (likertScale) {
                        averageScores.push(calculateAverageScore(likertHeader, likertScale) || 0);
                    } else {
                        averageScores.push(0);
                    }
                });
                datasets.push({
                    label: 'ì „ì²´ í‰ê·  ì ìˆ˜',
                    data: averageScores,
                    backgroundColor: activeGeneralPalette.slice(0, selectedLikertHeaders.length),
                });
            }

            return { labels: matrixLabels, datasets: datasets };
        }


        function addNewCrossAnalysisSection() {
            crossAnalysisSectionCounter++; const sectionIndex = crossAnalysisSectionCounter;
            const newSection = document.createElement('div'); newSection.id = `crossAnalysisConfig-${sectionIndex}`; newSection.className = 'cross-analysis-section mt-6 pt-6 border-t border-gray-300';
            newSection.innerHTML = `
                <button id="toggleCrossAnalysisBtn-${sectionIndex}" type="button" class="toggle-button w-full text-left mb-3">
                    <span><span class="toggle-icon inline-block transform transition-transform duration-200">&#9654;</span> <span class="section-index">3-${sectionIndex + 2}:</span> êµì°¨ ë¶„ì„ ì„¤ì • (í–‰ë ¬í˜• ë¦¬ì»¤íŠ¸)</span>
                    <button type="button" class="remove-button">ì‚­ì œ</button>
                </button>
                <div id="crossAnalysisSettings-${sectionIndex}" class="cross-analysis-settings hidden p-6 border border-dashed border-slate-300 rounded-lg bg-slate-50">
                    <p class="text-sm text-slate-600 mb-4">ë™ì¼í•œ ì‘ë‹µ ìœ í˜•ì„ ê°€ì§„ ì—¬ëŸ¬ ë¦¬ì»¤íŠ¸ ì²™ë„ ë¬¸í•­ë“¤ì˜ í‰ê·  ì ìˆ˜ ë˜ëŠ” ì‘ë‹µ ë¹„ìœ¨ì„ ê·¸ë£¹ë³„ë¡œ ë¹„êµí•©ë‹ˆë‹¤.</p>
                    <div class="grid md:grid-cols-2 gap-x-8 gap-y-4">
                        <div>
                            <label class="block text-sm font-medium text-slate-700 mb-1.5">ë¹„êµí•  ë¦¬ì»¤íŠ¸ ë¬¸í•­ë“¤ (ë‹¤ì¤‘ ì„ íƒ):</label>
                            <div id="crossAnalysisLikertQuestions-${sectionIndex}" class="cross-analysis-likert-questions-container">
                                <p class="text-sm text-slate-400">íŒŒì¼ ì—…ë¡œë“œ í›„ ë¦¬ì»¤íŠ¸ ë¬¸í•­ì´ ê°ì§€ë˜ë©´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.</p>
                            </div>
                        </div>
                        <div>
                            <div class="mb-4">
                                <label for="crossAnalysisGroupingQuestion-${sectionIndex}" class="block text-sm font-medium text-slate-700 mb-1.5">ê·¸ë£¹í™” ê¸°ì¤€ ë¬¸í•­ (ê°ê´€ì‹):</label>
                                <select id="crossAnalysisGroupingQuestion-${sectionIndex}" class="crossAnalysisGroupingQuestion w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-sky-500 focus:border-sky-500 appearance-none bg-white">
                                    <option value="">-- ë¬¸í•­ ì„ íƒ --</option>
                                </select>
                            </div>
                            <div>
                                <label for="crossAnalysisChartType-${sectionIndex}" class="block text-sm font-medium text-slate-700 mb-1.5">êµì°¨ ë¶„ì„ ì°¨íŠ¸ ìœ í˜•:</label>
                                <select id="crossAnalysisChartType-${sectionIndex}" class="crossAnalysisChartType w-full p-3 border border-slate-300 rounded-lg shadow-sm focus:ring-2 focus:ring-sky-500 focus:border-sky-500 appearance-none bg-white">
                                    <option value="averageScoreBar" selected>í‰ê·  ì ìˆ˜ ë¹„êµ (ê·¸ë£¹ ë§‰ëŒ€)</option>
                                    <option value="stackedPercentageBar">100% ëˆ„ì  ë¹„ìœ¨ ë§‰ëŒ€ (ê·¸ë£¹í˜•)</option>
                                    <option value="overallAverageScoreBar">ê°œë³„ ë¬¸í•­ ì „ì²´ í‰ê·  ë¹„êµ</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>`;
            crossAnalysisSectionsContainer.appendChild(newSection);
            
            populateCrossAnalysisLikertQuestions(newSection, sectionIndex); 
            
            const groupingSelect = newSection.querySelector(`#crossAnalysisGroupingQuestion-${sectionIndex}`);
            if (excelHeaders && excelHeaders.length > 0) { 
                excelHeaders.forEach(h => { 
                    if (questionTypes[h] !== 'subjective') { 
                        const o = document.createElement('option'); 
                        o.value = h; 
                        const qTTS = questionFullTexts[h] || h; 
                        const tT = qTTS.length > 40 ? qTTS.substring(0, 37) + '...' : qTTS; 
                        o.textContent = `${h} (${tT})`; 
                        groupingSelect.appendChild(o); 
                    }
                }); 
            }

            newSection.querySelector('.toggle-button').addEventListener('click', toggleCrossAnalysisSection);
            newSection.querySelector('.remove-button').addEventListener('click', () => { newSection.remove(); const secs = crossAnalysisSectionsContainer.querySelectorAll('.cross-analysis-section'); secs.forEach((s, i) => { const sIS = s.querySelector('.section-index'); if (sIS) sIS.textContent = `3-${i + 2}:`; }); });
            const allSecs = crossAnalysisSectionsContainer.querySelectorAll('.cross-analysis-section'); allSecs.forEach((s, i) => { const sIS = s.querySelector('.section-index'); if (sIS) sIS.textContent = `3-${i + 2}:`; });
        }

        function populateCrossAnalysisLikertQuestions(sectionElement, sectionIndex) {
            const container = sectionElement.querySelector(`#crossAnalysisLikertQuestions-${sectionIndex}`);
            if (!container) return;
            container.innerHTML = ''; // Clear previous content

            const likertHeaders = excelHeaders.filter(h => questionTypes[h] === 'likert');

            if (likertHeaders.length === 0) {
                container.innerHTML = '<p class="text-sm text-slate-400">ë¶„ì„ ê°€ëŠ¥í•œ ë¦¬ì»¤íŠ¸ ì²™ë„ ë¬¸í•­ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
                return;
            }

            likertHeaders.forEach((h, i) => {
                const d = document.createElement('div');
                d.className = 'flex items-center';
                const cId = `cb-cross-likert-${sectionIndex}-${h.replace(/[^a-zA-Z0-9]/g, "_")}-${i}`;
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.id = cId;
                cb.value = h;
                cb.className = 'h-4 w-4 rounded border-gray-300 text-sky-600 focus:ring-sky-500 cross-analysis-likert-item-checkbox';
                
                const l = document.createElement('label');
                l.htmlFor = cId;
                l.className = 'ml-2 block text-sm text-slate-700 cursor-pointer question-item-label';
                const qTextOriginal = questionFullTexts[h] || h;
                l.title = qTextOriginal;
                const truncatedText = qTextOriginal.length > 40 ? qTextOriginal.substring(0, 37) + '...' : qTextOriginal;
                l.textContent = `${h} (${truncatedText})`;
                
                d.appendChild(cb);
                d.appendChild(l);
                container.appendChild(d);
            });
        }


        function toggleCrossAnalysisSection(event) {
            const btn = event.currentTarget; const actualBtn = btn.closest('.toggle-button'); if (!actualBtn) return;
            const sec = actualBtn.closest('.cross-analysis-section'); if (!sec) return;
            const setDiv = sec.querySelector('.cross-analysis-settings'); const icon = actualBtn.querySelector('.toggle-icon');
            setDiv.classList.toggle('hidden'); icon.innerHTML = setDiv.classList.contains('hidden') ? '&#9654;' : '&#9660;'; icon.classList.toggle('open', !setDiv.classList.contains('hidden'));
        }
        
        // --- Label Edit Modal Functions ---
        let currentEditingChartIndex = -1;
        let tempCustomLabels = {};

        function openLabelEditModal(chartIndex) {
            currentEditingChartIndex = chartIndex;
            const chartInfo = activeCharts[chartIndex];
            if (!chartInfo || !chartInfo.chartData || !chartInfo.chartData.labels) {
                console.error("ì°¨íŠ¸ ì •ë³´ ë˜ëŠ” ë ˆì´ë¸” ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.", chartInfo);
                return;
            }

            tempCustomLabels = JSON.parse(JSON.stringify(chartInfo.customLabels || {})); // Deep copy

            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'modal-overlay';
            modalOverlay.id = 'labelEditModalOverlay';
            
            const modal = document.createElement('div');
            modal.className = 'label-edit-modal';
            modal.id = 'labelEditModal';

            const title = document.createElement('h3');
            title.className = 'text-lg font-medium leading-6 text-gray-900 mb-4';
            title.textContent = `"${chartInfo.customTitle || chartInfo.originalTitle}" ë ˆì´ë¸” í¸ì§‘`;
            modal.appendChild(title);

            const list = document.createElement('ul');
            
            // For basic charts, chartData.labels are the ones to edit
            // For matrix charts, matrixData.labels (X-axis) or dataset labels (legend)
            let labelsToEdit = [];
            if (chartInfo.type === 'basic') {
                labelsToEdit = chartInfo.chartData.labels;
            } else if (chartInfo.type === 'matrix' && chartInfo.chartData && chartInfo.chartData.labels) { // X-axis labels
                labelsToEdit = chartInfo.chartData.labels; 
                // If you also want to edit legend labels for matrix charts (groupingCategory)
                // you'd need to iterate through chartInfo.chartData.datasets.map(d => d.label)
            }


            labelsToEdit.forEach(originalLabel => {
                const listItem = document.createElement('li');
                
                const originalLabelSpan = document.createElement('span');
                originalLabelSpan.className = 'original-label-text';
                originalLabelSpan.textContent = originalLabel;
                originalLabelSpan.title = originalLabel; // Show full text on hover

                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'custom-label-input';
                input.value = tempCustomLabels[originalLabel] || originalLabel;
                input.dataset.originalLabel = originalLabel;

                if (originalLabel === OTHER_RESPONSE_LABEL || NO_RESPONSE_TERMS.includes(originalLabel)) {
                    input.disabled = true;
                }

                listItem.appendChild(originalLabelSpan);
                listItem.appendChild(input);
                list.appendChild(listItem);
            });

            modal.appendChild(list);

            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'modal-actions';

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'ì·¨ì†Œ';
            cancelButton.className = 'cancel-btn';
            cancelButton.onclick = () => {
                modalOverlay.remove();
                modal.remove();
            };

            const applyButton = document.createElement('button');
            applyButton.textContent = 'ì ìš©';
            applyButton.className = 'apply-btn';
            applyButton.onclick = () => applyLabelEdit(chartIndex);
            
            actionsDiv.appendChild(cancelButton);
            actionsDiv.appendChild(applyButton);
            modal.appendChild(actionsDiv);

            document.body.appendChild(modalOverlay);
            document.body.appendChild(modal);

            modalOverlay.addEventListener('click', () => { // Close on overlay click
                modalOverlay.remove();
                modal.remove();
            });
        }

        function applyLabelEdit(chartIndex) {
            const chartInfo = activeCharts[chartIndex];
            if (!chartInfo) return;

            const modal = document.getElementById('labelEditModal');
            if (!modal) return;

            const inputs = modal.querySelectorAll('.custom-label-input');
            const newCustomLabels = {};
            inputs.forEach(input => {
                const originalLabel = input.dataset.originalLabel;
                if (input.value.trim() !== originalLabel && input.value.trim() !== "") {
                    newCustomLabels[originalLabel] = input.value.trim();
                } else {
                    // If input is empty or same as original, remove from customLabels
                    delete newCustomLabels[originalLabel]; 
                }
            });
            
            chartInfo.customLabels = newCustomLabels;

            if (chartInfo.instance) {
                chartInfo.instance.destroy();
            }

            if (chartInfo.type === 'basic') {
                renderIndividualChart(chartIndex, chartInfo.currentChartType);
            } else if (chartInfo.type === 'matrix') {
                 generateCrossAnalysisChart({
                    likertQuestions: chartInfo.likertQuestions,
                    groupingQuestion: chartInfo.groupingQuestion,
                    crossChartType: chartInfo.crossChartType,
                    idSuffix: chartInfo.originalCanvas.id.split('-').pop()
                }, chartInfo.originalCanvas.id.split('-').pop(), true, chartIndex);
            }


            const modalOverlay = document.getElementById('labelEditModalOverlay');
            if (modalOverlay) modalOverlay.remove();
            modal.remove();
        }


        // Initialize color palette selector on DOM load
        document.addEventListener('DOMContentLoaded', () => {
            initializeColorPalettes();
             // ë¹Œë“œ ì •ë³´ í‘œì‹œ
            const buildInfoDiv = document.getElementById('buildInfo');
            if (buildInfoDiv) {
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                buildInfoDiv.textContent = `ë¹Œë“œ ë‚ ì§œ: ${year}-${month}-${day} / ë²„ì „: 2.1`;
            }
        });
    </script>
</body>
</html>
